

; todo: use a bunch of IFDEFs to hide all the debugging code
; when HW_ROWS >= 12.


; I used to use a FILL here but this made the hex dump too
; large to paste into web forms.
.DEFINE BASICMEMEND BASICMEM+38912

; keyboard constants
.DEFINE DCPU_BACKSPACE 0x10
.DEFINE DCPU_RETURN 0x11
.DEFINE DCPU_INSERT 0x12
.DEFINE DCPU_DELETE 0x13
.DEFINE DCPU_UP 0x80
.DEFINE DCPU_DOWN 0x81
.DEFINE DCPU_LEFT 0x82
.DEFINE DCPU_RIGHT 0x83
.DEFINE DCPU_SHIFT 0x90
.DEFINE DCPU_CTRL 0x91

.DEFINE CBM_RETURN 0x0D
.DEFINE CBM_DELETE 0x14
.DEFINE CBM_INSERT 0x94
.DEFINE CBM_UP 0x91
.DEFINE CBM_DOWN 0x11
.DEFINE CBM_LEFT 0x9D
.DEFINE CBM_RIGHT 0x1D
.DEFINE CBM_HOME 0x13
.DEFINE CBM_CLR 0x93
.DEFINE CBM_SPACE 0x20
.DEFINE CBM_QUOTE 0x22
.DEFINE CBM_COMMA 0x2C
.DEFINE CBM_COLON 0x3A


:ROMA000    DAT ROME394     ; Vector for starting BASIC
:ROMA002    DAT ROME37B

; C64 RAM equivalents
;

.INCLUDE "basic.dasm16"

:RAM90
:STATUS DAT 0
:RAM9D
:MSGFLG DAT 0           


:RAM91 ; stop key flag
:STKEY  DAT 0
:RAM93  
:VERCK  DAT 0
:RAM97
:XSAV   DAT 0
:RAM99  
:DFLTN  DAT 0
:RAM9A  
:DFLTO  DAT 3
:RAMC5  ; Code of last key pressed
:LSTX   DAT 0
:RAMC6  ; Number of Characters in Keyboard Queue
:NDX    DAT 0
:RAMC7 ; Reverse text? 0=no
:RVS    DAT 0
:RAMC8 ; Pointer: end of logical line for input
:INDX   DAT 0
:RAMC9 ; Cursor X,Y position at start of input
:LXSP   DAT 0
:RAMCA  DAT 0
:RAMCB ; Code of Current Key Pressed
:SFDX   DAT 0
:RAMCC  ; 0 = Flash Cursor
:BLNSW  DAT 0
:RAMCD  ; Countdown to blink cursor
:BLNCT  DAT 0
:RAMCE  ; Character under cursor
:GDBLN  DAT 0
:RAMCF ; Was last cursor blink on or off?
:BLNON  DAT 0
:RAMD0 ; Input from Keyboard (0) or Screen (3)
:CRSW   DAT 0
:RAMD1  ;Pointer to the Address of the Current Line
:PNT    DAT 0
:RAMD3 ;Cursor Column on Current Line
:PNTR   DAT 0
:RAMD4 ; Quote Mode (0=No)
:QTSW   DAT 0
:RAMD5 ; End of current line
:LNMX   DAT HW_COLS-1
:RAMD6 ; Current physical line number
:TBLX   DAT 0
; code of final character
:RAMD7  DAT 0
:RAMAC  
:SAL    DAT 0
:RAMAE  
:EAL    DAT 0
; scroll pointer
:SCPNT  DAT 0
:RAMB2  DAT 0
:RAMC1  DAT 0
; Filename and length
:RAMB7
:FNLEN  DAT 0
:RAMBB
:FNADR  DAT 0

; keyboard memory
;
; Keyboard Decode Table
:KEYTAB 
:RAMF5 DAT 0
:INSRT
:RAMD8 DAT 0
; Screen line link table
.DEFINE DL_UNLINKED 0x80
:LDTB1
:RAMD9
    .FILL HW_ROWS+1 DL_UNLINKED

; another floating point conversion thingy
:BASZPT 
:RAMFF DAT 0

;------

; This block of 256 bytes had the same function as the 6502 stack.
; Notable differences include:
;    originally, GOSUB pushed 5 bytes on the stack; now it pushes 3.
:STACK         
              .FILL 256 0
:STACKBASEND
                .FILL 6 0
:STACKEND


:RAM0277    ;KEYBOARD BUFFER
:KEYD
    .FILL KEYBOARD_BUFFER_SIZE 0

:RAM01FB  DAT 0
:RAM01FC  DAT 0
:RAM01FD  DAT 0
:RAM01FE  DAT 0
:RAM01FF  DAT 0
:RAM0200  ; String buffer?
    .FILL BASIC_BUFFER_LENGTH 0
:RAM0281 
:MEMSTR   ; Start of memory, only used once
        DAT BASICMEM
:RAM0283  ; End of memory found by RAMTAS
        DAT BASICMEMEND
:RAM0285 ; ???
        DAT 0
:RAM0287
:GDCOL  DAT 0xe620
:RAM0288
:HIBASE DAT SCREENMEM
;
:RAM0286
:COLOR  DAT 0xE600
:RAM0289
:XMAS   DAT 10
:RAM028A
:RPTFLAG    DAT 0
:RAM028B
:KOUNT      DAT REPEAT_FRAMES_B
:RAM028C
:DELAY      DAT REPEAT_FRAMES_A
:RAM028D
:SHFLAG     DAT 0
:RAM028E
:LSTSHF     DAT 0
:RAM028F
:KEYLOG     DAT 0 ; ROM?
:RAM0291
:MODE       DAT 0
:RAM0292
:AUTODN     DAT 0
; Temporary index to the next line for screen scrolling
:RAM02A5    DAT 0

; BASIC Indirect Vector Table
; if you guys want to port the DOS wedge go ahead
:RAM0300
:IERROR     DAT DEF_ERROR
:RAM0302
:IMAIN      DAT DEF_MAIN
:RAM0304
:ICRNCH     DAT DEF_CRUNCH    ; crunch tokens
:RAM0306
:IQPLOP     DAT DEF_QPLOP    ; print tokens
:RAM0308
:IGONE      DAT GONE        ; execute statement?
:RAM030A
:IEVAL      DAT DEF_EVAL
:RAM030C    DAT 0
; IRQ
:RAM0314    DAT ROMEA31
:RAM0316    DAT 0
:IIOBASE
:RAM0318    DAT ROME500
:IOPEN
:RAM031A    DAT DEF_OPEN
:ICLOSE
:RAM031C    DAT DEF_CLOSE
:ICHKIN
:RAM031E    DAT DEF_CHKIN
:ICHKOUT
:RAM0320    DAT DEF_CHKOUT
:ISOMETHING
:RAM0322    DAT ROMF333
:ICHRIN
:RAM0324    DAT DEF_CHRIN
:ICHROUT
:RAM0326    DAT DEF_CHROUT
:ISTOP
:RAM0328    DAT DEF_STOP
:IGETIN 
:RAM032A    DAT DEF_GETIN
:ICLALL  
:RAM032C    DAT DEF_CLALL
:RAM033C    DAT 0



:SCREENMEM    
               .FILL HW_COLS*HW_ROWS 0x4400
:SCREENMEMEND
; when HW_ROWS < 12, the bottom line displays
; various debugging information.
:DEBUGSPC
          DAT 0xA004, 0xA002, 0xA03A, 0xA020 ; "DB: "
; debug keyboard I/O
          DAT 0xA00B, 0xA03A ; "K:"
:DEBUGKEY
          .FILL 10 0x0
; debug line link tbl
        DAT 0xA00C, 0xA03A ; "L:" 
:DEBUGLNK 
        .FILL 14 0x0
; debug vblank interrupt
          DAT 0xA009, 0xA03A; "I:"
:DEBUGINT
          .FILL 6 0x0

          .FILL HW_COLS-29 0xA02E




; get screen geometry
:DEF_SCREEN
:ROME505    SET X, HW_COLS
            SET Y, HW_ROWS
            RTS

; set cursor x/y
:DEF_PLOT
:ROME50A   IFN C, 0
              JMP ROME513
           SET [TBLX], X  ; Line number
           SET [PNTR], Y  ; Column
           JSR ROME56C
 :ROME513  SET X, [TBLX]
           SET Y, [PNTR]
           RTS


; SET NEXT LINE NUMBER

:ROME87C    SHR [RAMC9], 1 ; LSR $C9?
            SET X, [TBLX]
:ROME880    ADD X, 1
            IFE X, HW_ROWS
                JSR ROME8EA ; scroll the screen
            IFC [X+LDTB1], DL_UNLINKED  ; if linked
                JMP ROME880 ; repeat test with next line
            SET [TBLX], X
:ROME88E    JMP ROME56C ; Set PNT to current line

; action for RETURN
:ROME891    SET [INSRT], 0
            SET [RVS], 0
            SET [RAMD4], 0
            SET [PNTR], 0 ; column 0
            JSR ROME87C ; Move cursor to next line
            JMP ROME6A8 ; Return from outputting

; move cursor to previous line if at start of line
:ROME8A1    SET X, ROWS_IN_LINE ;2
            SET A, 0
:ROME8A5    IFE [PNTR], A  ; 
                JMP ROME8B0
            ADD A, HW_COLS
            SUB X, 1
            IFN X, 0
                JMP ROME8A5
            RTS
:ROME8B0    SUB [TBLX], 1
            RTS

; move cursor to next line if at end of line
:ROME8B3    SET X, ROWS_IN_LINE ;2
            SET A, HW_COLS-1
:ROME8B7    IFE [PNTR], A
                JMP ROME8C2
            ADD A, HW_COLS
            SUB X, 1
            IFN X, 0
                JMP ROME8B7
            RTS
:ROME8C2    SET X, [TBLX]
            IFN [TBLX], HW_ROWS
                ADD [TBLX], 1
            RTS

; check for color change codes
:ROME8CB
            SET X, 0x0f
:ROME8CD    IFE A, [ROME8DA+X]
                JMP ROME8D6
            SUB X, 1
            IFA X, -1
                JMP ROME8CD
            RTS
:ROME8D6    AND [COLOR], 0x0F00
            SHL X, 12
            BOR [COLOR], X
            RTS

:ROME8DA ; color codes
    DAT 0x90, 0x05, 0x1c, 0x9f, 0x9c, 0x1E, 0x1F, 0x9E
    DAT 0x81, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b

; scroll screen
:ROME8EA    
:ROME8F6    SET X, -1
            SUB [TBLX], 1
            SUB [LXSP], 1
            SUB [RAM02A5], 1  ; a temporary index
:ROME8FF    ADD X, 1
            JSR ROME9F0  ; set PNT line pointer to X
            IFG X, HW_ROWS-2  ; CPS #$18
                JMP ROME913   ; BCS $E913
            SET A, X
            ADD A, 1
            MUL A, HW_COLS
            ADD A, [HIBASE]
            SET [SCPNT], A
            JSR ROME9C8 ; move line up
            JMP ROME8FF
:ROME913    JSR ROME9FF ; clear a screen line
            SET X, 0
:ROME918    SET [LDTB1+X], [LDTB1+1+X]
            ADD X, 1
            IFl X, HW_ROWS-1
                JMP ROME918
            SET [LDTB1+HW_ROWS-1], DL_UNLINKED
:ROME92F    IFC [LDTB1], DL_UNLINKED ; top line was linked
                JMP ROME8F6   ; scroll another line
            ADD [TBLX], 1
            ADD [RAM02A5], 1
:ROME938    ; Test for CTRL key
; CTRL key pausing
:ROME93A
; ...
;:ROME94D   SET X, X; ; NOP
;           SUB X, 1;
;           IFN X, 0
;               JMP ROME94D
:ROME954    SET [NDX], 0
:ROME956    SET X, [TBLX]
:ROME958    RTS
; insert blank line in screen
:ROME965
            SET X, [TBLX] ; current line
:ROME967    ADD X, 1
            SET A, [LDTB1+X]
            IFC A, DL_UNLINKED ; LONE LINE
                JMP ROME967
            SET [RAM02A5], X ; RAM02A5 is first unlinked line
                             ; below initial X value.
            IFL X, HW_ROWS
                JMP ROME981
            SET X, [RAM02A5]
            SUB X, 1
            SUB [TBLX], 1
            JMP ROME6DA ; Link line X with next line

:ROME981    
            SET X, HW_ROWS
:ROME98F    SUB X, 1
            JSR ROME9F0  ; set PNT line pointer to X
            IFL X, [RAM02A5]
                JMP ROME9A6
            IFE X, [RAM02A5]
                JMP ROME9A6
            SET A, X
            MUL A, HW_COLS
            ADD A, [HIBASE]
            SET [SCPNT], A
            JSR ROME9C8  ; Move line up
            JMP ROME98F ; repeat with previous line
:ROME9A6    JSR ROME9FF ; Clear a screen line
:ROME9A9    SET X, HW_ROWS-2
:ROME9AB        IFL X, [RAM02A5]
                JMP ROME9BF
:ROME9B0    SET A, 0  ; no longer need to preserve addr
        IFB [LDTB1+X], DL_UNLINKED
            BOR A, DL_UNLINKED
:ROME9BA    SET [LDTB1+1+X], A
            SUB X, 1
            IFN X, 0
            JMP ROME9AB
:ROME9BF    SET X, [RAM02A5]
            JSR ROME6DA ; link line X with next line
            JMP ROME958 ; RTS

; move one screen line from [SCPNT] to [PNT]
; Instead of passing in a high byte in A,
; make sure the whole source address is in [SCPNT].
:ROME9C8
            SET Y, HW_COLS-1
            SET I, [SCPNT]
            ADD I, Y
            SET J, [PNT]
            SET A, J
            ADD J, Y
:ROME9D4
            STD [J], [I] 
            IFN J, A
                JMP ROME9D4
            SET [J], [I] ; first character
            RTS

    
; set color/screen addresses
:ROME9E0    ; Unnecessary
            RTS

; fetch screen addresses
:ROME9F0    ;SET A, [ROMECF0+X]
            ;ADD A, [RAM0287]
            SET A, X
            MUL A, HW_COLS
            ADD A, [HIBASE]
            SET [PNT], A
            RTS

; clear one screen line
:ROME9FF
            JSR ROME9F0   ; set [PNT] line pointer to line X
            SET I, [PNT]
            SET J, HW_COLS-1
            ADD I, J
            SET A, 0x0020 
            BOR A, [COLOR]
:ROMEA07    STD [I], A
            IFN J, -1
                JMP ROMEA07
            RTS

; set cursor flash timing
; (and color memory addresses)
:ROMEA13
    SET [BLNCT], 2
    ;JSR ROMEA24

    ; put a char on the screen
; color in X
; character in A

:ROMEA1C
    ;SET EX, 0xea1c
    ;IFU [PNT], SCREENMEM
    ;   JMP CRASH
    AND A, 0xFF
    AND X, 0xFF00
    BOR A, X
    SET Y, [PNTR]
    ADD Y, [PNT]
    SET [Y], A
:ROMEA23    RTS

:ROMEA24 ; Unnecessary because the LEM1802
        ; display doesn't have separate color memory
        RTS

; normal IRQ interrupt
:IRQ_HANDLER
:ROMEA31    
    ;SET [DEBUGINT+0], [RAMCD]
    ;BOR [DEBUGINT+0], 0xC400
    ;SET [DEBUGINT+1], [RAM028C]
    ;BOR [DEBUGINT+1], 0xC000
    ;SET [DEBUGINT+2], [RAM028B]
    ;BOR [DEBUGINT+2], 0xC000
            ;JSR ROMFFEA ; do clock
            IFN [BLNSW], 0
                JMP ROMEA61
            ; FLASH CURSOR
            SUB [BLNCT], 1
            IFN [BLNCT], 0
                JMP ROMEA61
            SET [BLNCT], BLINK_FRAMES
            XOR [BLNON], 1  ; was last blink on/off?
            SET A, [PNTR] ; CURSOR POSITION
            ADD A, [PNT]
            IFE [BLNON], 0  ; last blink was off
                JMP ROMEA5C
            SET [GDBLN], [A] ; store chr under cursor
            JSR ROMEA24
            SET Y, [COLOR]
            SET X, Y
            AND Y, 0x0F00
            SHL Y, 4
            AND X, 0xF000
            SHR X, 4
            BOR X, Y
            AND [A], 0xFF   ; blink on-phase
            BOR [A], X
            IFE A, -1 ; SKIP
:ROMEA5C    SET [A], [GDBLN] ; blink off-phase
:ROMEA61    ; check cassette?
:ROMEA7B    JSR ROMEA87 ; scan keyboard
            SET Y, POP
            SET X, POP
            SET EX, POP
            RFI

:SCANREG
:SCANSHIFT
    SET Y, [KEYASCII]
    IFL Y, 0x20
        JMP SCANSPECIAL
    IFB Y, 0x80
        JMP SCANARROWS
    SET [SFDX], Y
    ; handle letter shifting
    IFG Y, 0x60 ; lowercase letters
        SUB [SFDX], 0x20  ; are "unshifted"
    IFG Y, 0x40
      IFL Y, 0x5B
        ADD [SFDX], 0x80
    RTS

:SCANSPECIAL
    SET [SFDX], CBM_RETURN
    IFE Y, DCPU_INSERT
        SET [SFDX], CBM_INSERT
    IFE Y, DCPU_BACKSPACE
		JMP SCAN_DELETE
    IFN Y, DCPU_DELETE
    	JMP SCAN_NOT_DELETE
:SCAN_DELETE
	IFC [SHFLAG], 1  ; unshifted
        SET [SFDX], CBM_DELETE
	IFB [SHFLAG], 1  ; shifted
        SET [SFDX], CBM_INSERT
:SCAN_NOT_DELETE
    RTS

:SCANCTRL
    SET [SFDX], CBM_RETURN
    RTS

:SCANCBM
    RTS

:SCANARROWS
    IFE Y, DCPU_RIGHT
        SET [SFDX], CBM_RIGHT 
    IFE Y, DCPU_DOWN
        SET [SFDX], CBM_DOWN 
    IFE Y, DCPU_LEFT
        SET [SFDX], CBM_LEFT
    IFE Y, DCPU_UP
        SET [SFDX], CBM_UP 
    RTS
            
; scan keyboard
:ROMEA87 
    JSR DISPLAY_INPUT_BUFFER    
    SET [SHFLAG], [KEYSHIFT]
    SET [SFDX], 0x407F ; code for NO KEY PRESSED
        IFE [KEYASCII], 0
            JMP ROMEAE0
        IFC [KEYSHIFT], 0x07 ; no shift-ctrl
        JSR SCANREG
    IFE [KEYSHIFT], 0x01 ; SHIFT only
        JSR SCANSHIFT
    IFE [KEYSHIFT], 0x04 ; CTRL only
        JSR SCANCTRL
    IFE [KEYSHIFT], 0x05 ; CBM (shift+ctrl)
        JSR SCANCBM
        JSR DISPLAY_KEY_DEBUG
        ;JSR DISPLAY_LINK_TABLE
:ROMEAE0
    SET Y, [SFDX] ; key being pressed
        SET A, Y   ; [SFDX] contains the actual value, not scan code
        SET X, A   ; because EAE4 said so
    IFE [SFDX], [LSTX]
        JMP ROMEAF0
    SET [RAM028C], REPEAT_FRAMES_A   ; key repeat speed
;   SET [RAM028B], REPEAT_FRAMES_B   ; key repeat speed
    JMP ROMEB26
:ROMEAF0 
    ; clear shift bit so that we can test for
    ; a character and its shifted equivalent
    ; at the same tims.
        AND A, 0x407F
:ROMEAF2
    ; handle key repeat logic
    IFB [RAM028A], 0x80
        JMP ROMEB0D ; repeat all characters
    IFB [RAM028A], 0x40
        RTS        ; repeat no characters
    IFB A, 0x4000  ; no key pressed
        JMP ROMEB26
    ; repeat only these characters
    IFE A, CBM_DELETE  ;and insert
        JMP ROMEB0D
    ; no need to software-repeat the space
    ; the dcpu does it for us?
    ;IFE A, 0x20 ; SPACE
    ;    JMP ROMEB0D
    IFE A, CBM_RIGHT ; cursor right/left
        JMP ROMEB0D
    IFN A, CBM_DOWN ; cursor up/down
        RTS
:ROMEB0D ; repeat this key
    IFE [RAM028C], 0
        JMP ROMEB17
    SUB [RAM028C], 1
    IFN [RAM028C], 0
        RTS
:ROMEB17
    SUB [RAM028B], 1
    IFN [RAM028B], 0
        RTS
:ROMEB1C    SET [RAM028B], REPEAT_FRAMES_B ; repeat speed
:ROMEB21   
            SET Y, [NDX]
            SUB Y, 1
            IFC Y, 0x8000 ; BPL
                RTS
:ROMEB26
            SET [LSTX], [SFDX]
            IFN [LSTSHF], [0x01]
                JMP SKIPSHIFTCBM
            IFE SHFLAG, 0x05
                ;JSR TOGGLEFONT ; why doesn't this work
:SKIPSHIFTCBM
            SET [LSTSHF], [SHFLAG]
            IFB A, 0x4000 ; no key pressed
                RTS
:ROMEB35
            SET X, [NDX]
            IFG X, KEYBOARD_BUFFER_SIZE  ; keyboard buffer overflow
                RTS
:ROMEB3C    ; Add A to keybuard queue
            SET [KEYD+X], A
            ADD [NDX], 1
:ROMEB47
            RTS

:DISPLAY_INPUT_BUFFER
    SET PUSH, X
    SET PUSH, I
    SET PUSH, J
    SET I, [FREETOP]
    SET J, DEBUGLNK-1
:BUFLOOP
    STI X, [I]
    IFC X, 0xFF00
        JMP BUF99
    AND X, 0xFF
    BOR X, 0xB300
    JMP BUF88
:BUF99
    BOR X, 0x6E00
:BUF88 SET [J], X
    IFL J, DEBUGLNK+15
    JMP BUFLOOP
    SET J, POP
    SET I, POP
    SET X, POP
RTS

; I appropriated this to display another
; chunk of memory in the status bar.
:DISPLAY_LINK_TABLE
        SET PUSH, I
        SET PUSH, J
        SET I, LDTB1
        SET J, DEBUGLNK-1
:LINKLOOP
        STI X, [I]
        SET [J], 0x192E
        IFC X, DL_UNLINKED
            SET [J], 0x1921
        IFL I, LDTB1+HW_ROWS+3
        JMP LINKLOOP
        SET J, POP
        SET I, POP
        RTS

:HEXTHING
   .FILL 10 48
   .FILL 6 -9
:DISPLAY_KEY_DEBUG
        ; debugging code to display some registers every frame
        SET Y, [COUNT]  ; 
        SET X, DEBUGKEY+9
        SET PUSH, B
:DBGLOOP
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+5
           JMP DBGLOOP
        ; another one
        SUB X, 1
        SET Y, [VARTAB]
        ;SET [Y], 0x41
:DBGLOOP2
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+0
           JMP DBGLOOP2
        SET B, POP

:ROMEAE0 
;Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer


:ROMEB48    ;Set up proper keyboard decode table
            RTS
; load/run for RUN key

:ROMEC44    IFN A, 0x0E ; Lowercase code
                JMP ROMEC4F
            ; TODO: FINISH
:ROMEC4F    IFN A, 0x8E ; Uppercase code
                JMP ROMEC5E
            ; TODO: FINISH
            
; SHIFT-C= KEY CHECK
:ROMEC5E
    ; TODO: FINISH
            JMP ROME6A8

; Offsets of screen line addresses
:ROMECF0  DAT 0, HW_COLS
    DAT HW_COLS*2, HW_COLS*3
    DAT HW_COLS*4, HW_COLS*5
    DAT HW_COLS*6, HW_COLS*7
    DAT HW_COLS*8, HW_COLS*9
    DAT HW_COLS*10, HW_COLS*11
    

; input a character
; get a character

:CHRCOUNT DAT 0
; STUB SCREEN OUTPUT
:COLUMN      DAT 0
:SCREENPTR  DAT SCREENMEM

:ROME716    SET PUSH, A
            AND A, 0xFF ; PETSCII is 8-bit
            SET [RAMD7], A
            SET PUSH, X
            SET PUSH, Y
            SET PUSH, I
            SET PUSH, J
            SET [CRSW], 0
            SET Y, [PNTR]
            IFB A, 0x0080 
                JMP ROME7D4
            ; Handle unshifted characters
:ROME72A    IFE A, CBM_RETURN  
                JMP ROME891  ; handle CR
            IFL A, 0x20
                JMP ROME745
            IFL A, 0x60
                JMP ROME73D
            AND A, 0xDF
            IFN A, 0
                JMP ROME73F
:ROME73D    AND A, 0x3F
:ROME73F    JSR ROME684 ; handle quote flag
            JMP ROME693  ; print character
:ROME745    SET X, [INSRT]
            IFN X, 0
                JMP ROME697  ; print reverse
            IFN A, CBM_DELETE 
                JMP ROME77E
            IFN Y, 0
                JMP ROME759
            JSR ROME701 ; move cursor bak does two POPs
            SET I, [PNT]
            ADD I, Y
            JMP ROME773
:ROME759    JSR ROME8A1 ; move cursor to prev line if at start
    ; Move rest of line to the left with the cursor.
            SUB Y, 1
            JSR ROMEA24
            SET [PNTR], Y
            SET I, [PNT]
            SET J, [PNT]  ; J = end of line
            ADD J, [LNMX]
            ADD I, Y
:ROME762    ADD I, 1
            SET [I-1], [I]
            IFN I, J  ;END OF LINE
                JMP ROME762
:ROME773    SET J, 0x0020 ; spave
            BOR J, [COLOR]
            SET [I], J 
            JMP ROME6A8
:ROME77E    IFN [QTSW], 0
                JMP ROME697  ; print reverse
:ROME785    IFE A, 0x12  ; RVS code
                SET [RVS], A
            IFE A, CBM_HOME 
                JSR ROME566
            IFN A, CBM_RIGHT 
                JMP ROME7AD
:ROME796        ; do crsr-right
            ADD Y, 1
            JSR ROME8B3 ; handle end-of-line condition
            SET [PNTR], Y
            SUB Y, 1
            IFL Y, [LNMX]
                JMP ROME6A8 ; return from print
            SUB [TBLX], 1
            JSR ROME87C ; move cursor to next line
            SET Y, 0
:ROME7A8    SET [RAMD3], Y
            JMP ROME6A8 ; return from print
:ROME7AD    IFN A, CBM_DOWN 
                JMP ROME7CE
            ; perform cursor down
            ; first assume we're in a linked line
            ADD Y, HW_COLS
            ADD [TBLX], 1
            IFL Y, [LNMX]
                JMP ROME7A8
            IFE Y, [LNMX]
                JMP ROME7A8
            SUB [TBLX], 1
:ROME7C0    SUB Y, HW_COLS
            IFU Y, 0
                JMP ROME7C8
                SET [RAMD3], Y
            IFN Y, 0
                JMP ROME7C0
:ROME7C8
            JSR ROME87C ; move cursor to next line
            JMP ROME6A8 ; return from print
:ROME7CE    JSR ROME8CB
            JMP ROMEC44
            
; Put shifted chars to screen

:ROME7D4    AND A, 0x7F ; remove shift bit
            IFE A, 0x7F ; code for PI
                SET A, 0x5E
            IFG A, 0x1F ; printable
                JMP ROME691 ; add 64 and print
:ROME7E3    IFE A, CBM_RETURN ; shift return
                JMP ROME891 ; HANDLE CR
            IFN [QTSW], 0
                JMP ROME82D
            IFN A, CBM_DELETE ; insert
                JMP ROME829
            ; TODO: complete insert routine
            SET Y, [RAMD5]
            SET A, [RAMD1]
            ADD A, Y   ; A contains end of space to be inserted
            SET A, [A]
:ROME7F6    AND A, 0xFF
            IFN A, CBM_SPACE
                JMP ROME7FE
            IFN Y, [PNTR]
                JMP ROME805 ; No need to insert a line
:ROME7FE    IFE Y, (HW_ROWS*ROWS_IN_LINE)-1
                JMP ROME6A8 ; do nothing; can't expand further
:ROME802    JSR ROME965 ; Insert a line below the current line
:ROME805    SET PUSH, I
            SET PUSH, J
            SET I, [LNMX]
            STD J, I  ; decrement both 
            ADD J, [PNT] 
            ;JSR ROMEA24
:ROME80A    STD [J+1], [J]
            IFN I, [PNTR]
                JMP ROME80A
            SET [J+1], [J] ; do one more
            ; fill in space
            SET I, [COLOR]
            AND I, 0xFF00
            BOR I, 0x0020
            SET [J], I ; TODO: Proper color
            SET J, POP
            SET I, POP
            ADD [INSRT], 1
            JMP ROME6A8
:ROME829    IFE [INSRT], 0
                JMP ROME832
:ROME82D    BOR A, 0x40  ; shift character
            JMP ROME697  ; and print reverse
:ROME832    IFN A, CBM_DOWN ; cursor up
                JMP ROME84C
            SET X, [TBLX]
            IFE X, 0
                JMP ROME6A8 ; Do nothing, return.
            SUB [TBLX], 1
            SET A, [PNTR]
            SUB A, HW_COLS
            IFU A, 0
                JMP ROME847
            SET [PNTR], A
            IFA A, -1 ; BPL
                JMP ROME6A8
:ROME847    JSR ROME56C ; get address
            JMP ROME6A8 ; retunr from print

:ROME84C    IFE A, 0x12 ; reverse off
                SET [RVS], 0
            IFN A, CBM_RIGHT ; cursor left
                JMP ROME86A
            ; do crsr left
            IFE Y, 0
                JMP ROME864
            JSR ROME8A1 ; handle edge of screen?
            SUB Y, 1
            SET [RAMD3], Y
            JMP ROME6A8
:ROME864    JSR ROME701
            JMP ROME6A8
:ROME86A    IFN A, CBM_HOME ; clr code
                JMP ROME874
            JSR ROME544
            JMP ROME6A8
:ROME874    BOR A, 0x80 ; restore high bit
            JSR ROME8CB ; check for color change codes
            JMP ROMEC4F
            

        
            
; KERNAL STUBS
:ROME37B    RTS

:DEF_IOBASE
:ROME500    RTS
; initialize screen and keyboard
:ROME518    
            ;JSR ROME5A0 ; initialize VIC chip - skip
            SET [MODE], 0
            SET [BLNON], 0   
            SET [RAM028F], ROMEB48
            SET [BLNCT], 12
            SET [BLNSW], 12
            ;SET [CRSW], 12
            SET [XMAS], 10
            SET [RAM028A], 10
            SET [COLOR], 0xE600 ; lt blue on blue
            SET [RAM028C], REPEAT_FRAMES_A   ; key repeat speed
            SET [RAM028B], REPEAT_FRAMES_B   ; key repeat speed
:ROME544    ; Initialize screen link table
            ; and clear the screen.  The 16-bit
            ; version doesn't need to attach
            ; the high byte of memory to this.
            SET I, LDTB1
            SET J, 0
:LINCLRLOOP STI I, DL_UNLINKED ; DISCONNECTED
            IFN J, HW_ROWS+1
                JMP LINCLRLOOP
            SET I, -1 
            SET X, HW_ROWS-1 ; ?
:ROME560    JSR ROME9FF  ; clear one screen line
            SUB X, 1
            IFA X, -1 ; BPL
                JMP ROME560
:ROME566
            SET [PNTR], 0 ; column 0
            SET [TBLX], 0 ; row 0
; set address of current screen line
:ROME56C
            SET X, [TBLX]
:ROME570    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME57C
            ; this is 32 characters further
            ; in the previous line
            ADD [PNTR], HW_COLS
            SUB X, 1
            IFA X, -1
                JMP ROME570
:ROME57C    JSR ROME9F0 ; set PNT line pointer
            SET A, HW_COLS-1
            ADD X, 1
:ROME582    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME58C
            ADD A, HW_COLS
            ADD X, 1
            JMP ROME582
:ROME58C    SET [LNMX], A ; maximum line length
                JMP ROMEA24
            RTS
:ROME591    IFN X, [LXSP]
                RTS
            JMP ROME6ED ; find beginning of logical line
:LP2       ; get a character from the keyboard buffer
:ROME5B4    SET Y, [KEYD] 
            SET X, 0
:ROME5B9    SET [KEYD+X], [KEYD+1+X]
            ADD X, 1
            IFN X, [NDX]
               JMP ROME5B9
            SUB [NDX], 1
            SET A, Y
            IAQ 0
            SET EX, 0
            RTS
; WAIT FOR RETURN FOR KEYBOARD
:ROME5CA    JSR ROME716 ; output to the screen
:ROME5CD    SET A, [NDX]
            SET [BLNSW], A  ; only blink if buffer is empty
            SET [AUTODN], A ; Don't scroll until buffer is empty
            IAQ 0 ; this wasn't necessary in the c64 rom
            IFE A, 0
                JMP ROME5CD ; Loop until something changes?
:ROME5D6    IAQ 1 ; SEI
            IFE [BLNON], 0
                JMP ROME5E7
            ; restore haracter under cursor
            SET A, [GDBLN]
            SET [BLNON], 0
            SET A, [PNT]
            ADD A, [PNTR]
            SET [A], [GDBLN]  ; was a call to EA13
:ROME5E7    JSR ROME5B4 ; get character from buffer
            IFN A, 0x83 ; RUN key
                JMP ROME5FE
            ; copy LOAD and RUN into buffer
            ;SET X, 9
            ;IAQ 1
            ;SET [NDX], X
:ROME5F3    ;DAT 0x5000
        ;JMP ROME5CD
:ROME5FE    IFN A, CBM_RETURN 
                JMP ROME5CA
            SET Y, [LNMX]
            SET [CRSW], Y
            ADD Y, [PNT]
:ROME606    SET A, [Y]
            AND A, 0xFF
            IFN A, 0x20 ; SPACE
                JMP ROME60F
            SUB Y, 1
            IFN Y, [PNT] ; TODO: fix off-by-one
                JMP ROME606
:ROME60F    ADD Y, 1
            SET [INDX], Y ; mark end of logical line
:ROME612    SET Y, 0
            SET [AUTODN], Y ;temporarily hold scrolling
            SET [PNTR], Y ; beginning of line
            SET [QTSW], Y ; turn off quote mode
            SET A, [LXSP] ; get column at start of input
            IFG [LXSP], 0x7F ; BMI
                JMP ROME63A ; get chr from screen
            SET X, [TBLX]  
:ROME621    JSR ROME591
            IFN X, [LXSP]
                JMP ROME63A  ; get chr from screen
            SET A, [LXSP+1]
            SET [PNTR], A
            IFU A, [INDX]  
                JMP ROME63A  ; get chr from screen
            JMP ROME65D
:ROME632    ; get character from device 0 or 3
            SET PUSH, Y
            SET PUSH, X
            IFE [CRSW], 0
                JMP ROME5CD ; blink cursor, etc
; get character from current screen line
:ROME63A    SET Y, [PNTR]
            ADD Y, [PNT] ; Y <- current character location
            SET A, [Y]   ; A <- current character byte
; TODO: handle RVS text somehow
            AND A, 0xFF
            SET [RAMD7], A
            AND A, 0x3F
            ; TODO: clean up for DCPU-16.
:ROME642    ; we don't need anyu shifting here
            ;SHL [RAMD7], 1
:ROME646    IFC [RAMD7], 0x40  ; original 0x40
                JMP ROME64A
            BOR A, 0x80
:ROME64A    IFC [RAMD7], 0x80         ; original 0x80
                JMP ROME650
            IFN X, [QTSW]
                JMP ROME654
:ROME650    IFB [RAMD7], 0x20   ; ASCII punctuation range
                JMP ROME654    ; leave undisturbed
:ROME652    BOR A, 0x40  ; 
:ROME654    ADD [PNTR], 1
            JSR ROME684 ; handle quote flag
:ROME659    IFN Y, [INDX]
                JMP ROME674
:ROME65D    SET [CRSW], 0 ; 
            SET A, CBM_RETURN
            IFE [DFLTN], 3
                JMP ROME66F
            IFE [DFLTO], 3
                JMP ROME672
:ROME66F    JSR ROME716 ; output to the screen
:ROME672    SET A, CBM_RETURN  ; Register EOL
:ROME674    SET [RAMD7], A ; code of final character
            SET X, POP
            SET Y, POP
            IFE A, 0xDE ; screen PI code
                SET A, 0xFF ; petscii PI code
:ROME682    SET EX, 0  ; clc
                SET C, 0
            RTS

; check for quote mark and set flag
; (6502 version took 13 bytes;
; this one takes 5 bytes)
:ROME684    IFE A, CBM_QUOTE
                XOR [QTSW], 1
            RTS
            
            
; fill screen at current position
:ROME691    BOR A, 0x40 
:ROME693    IFN [RVS], 0
:ROME697        BOR A, 0x80  ; this means "blink" on LEM.
:ROME699    IFN [INSRT], 0
                SUB [INSRT], 1
            SET X, [COLOR]
            ; TODO: proper RVS handling
            JSR ROMEA13 ; place character on screen
            JSR ROME6B6 ; advance cursor
            
; return from output to the screen
:ROME6A8    
            SET J, POP
            SET I, POP
            SET Y, POP
            IFN [INSRT], 0
                SHR [QTSW], 1
            SET X, POP
            SET A, POP
            SET EX, 0
            IAQ 0  ; RE-ENABLE INTERRUPTS
            RTS

;advance the cursor, Get/insert new line
:ROME6B6    JSR ROME8B3 ; move cursor to next line if 
                   ; at end of line -- X will equal old line number
            ADD [PNTR], 1
:ROME6BB    SET A, [LNMX]
            IFL A, [PNTR]
                JMP ROME6C1
            RTS
:ROME6C1            ; this branch is for when you type past the maximum logical line length
            IFE [LNMX], (HW_COLS*ROWS_IN_LINE)-1
                JMP ROME6F7
            IFN [AUTODN], 0  ; if scrolling enabled
                JMP ROME967 ; insert blank line
:ROME6CD    SET X, [TBLX]
            IFL X, HW_ROWS
                JMP ROME6DA ; skip scrolling
            JSR ROME8EA  ; scroll the screen first
            SUB [TBLX], 1
            SET X, [TBLX]
            ; link current line (X) with next line
:ROME6DA    AND [LDTB1+X], 0xFFFF-DL_UNLINKED
            BOR [LDTB1+1+X], DL_UNLINKED
:ROME6E6    ADD [LNMX], HW_COLS
:ROME6ED    IFB [LDTB1+X], DL_UNLINKED
                JMP ROME6F4
            SUB X, 1
            IFN X, 0
                JMP ROME6ED
:ROME6F4    JMP ROME9F0 ; set PNT line pointer to X
:ROME6F7    SUB [TBLX], 1
            JSR ROME87C ; Move cursor to next line
            SET [PNTR], 0 ; beginning of
            RTS
; move backwards over a line boundary
:ROME701    SET X, [TBLX]
        IFN X, 0 ; at top of screen?
                JMP ROME70B
            SET [PNTR], 0 ; ?  column 0
            ;SET A, POP  ; not sure why we pop
            ;SET A, POP
            ;IFN A, 0
                JMP ROME6A8
:ROME70B    SUB X, 1
            SET [TBLX], X
            JSR ROME56C
            SET [PNTR], [LNMX] ; end of line?
            RTS

:ROME386
            SET X, 0x80
            JMP [IERROR] ;normally E38B
:DEF_ERROR    
:ROME38B ; error message handler
            SET A, X
            IFG A, 0x7F
                JMP READY
            JMP BASIC_ERROR
    
:ROME394  ; ** COLD START BASIC
            ;JSR ROME453 ; don't need to initialize vectors
            JSR INIT ; Initialize BASIC
            JSR ROME422 ; Print start-up messages
            SET SP, STACKBASEND
            JMP ROME386


; In CBM BASIC, this was copied to 0073.
; In DCPU-16, I'm just defining this address
; because there's a BASIC variable fetch routine
; that inexplicably used this address as some
; kind of comparison.
:INITAT
:ROME3A2    dat 0x9000

:INIT
:ROME3BF
            SET A, 0x4C ; ? 
            SET [USRPOK], A
            SET [RAM0311], FCERR
            SET [RAM05], GIVAYF
            SET [RAM03], ROMB1AA
            ; skipped code that copies CHRGET/CHRGOT
            SET [FOUR6], 2  ; single string descriptor
            SET [BITS], 0
            SET [CHANNL], 0
            SET [LASTPT], 0
            ; TODO: figure out why we're doing this
            ; with the stack
            ;SET [RAM01FD], 1
            ;SET [RAM01FC], 1
            SET [TEMPPT], TEMPST ; string stack to beginning
            SET C, 1
            SET B, 123
            JSR MEMBOT
            ; Set [TXTTAB] to beginning of BASIC area
            SET [TXTTAB], X
            SET B, 0xFFFF
            SET C, 1
            JSR MEMTOP
            SET [MEMSIZ], X
            SET [FREETOP], X
            SET Y, [TXTTAB]
            SET [Y], 0
            ADD [TXTTAB], 1
            RTS   ; 0x4B1?

    ; PRINT BASIC STARTUP MESSAGES
:ROME422
            SET A, [TXTTAB]
            JSR REASON
            SET A, ROME473  ; COMMODORE 64 BASIC V2
            JSR STROUT
            ; Calculate number of basic bytes free
            SET A, [MEMSIZ]
            SUB A, [TXTTAB]
            JSR LINPRT
            SET A, WORDS  ; BASIC BYTES FREE
            JSR STROUT
            ; prefill keyboard buffer with 
            JSR RUN_TEST_STRING
            ; go to READY prompt
            JMP ROMA644  ; NEW statement.
            
; startup messages

:WORDS      DAT " BASIC BYTES FREE"
            DAT CBM_RETURN, 0
:ROME473    DAT CBM_CLR ;to clear the screen
            DAT 0x05, " ** "
            DAT "DCPU-16 BASIC V2 **"
            DAT 0x9A
            DAT CBM_RETURN, CBM_RETURN
            ;DAT " 64K RAM SYSTEM  "
            DAT 0
:ROME4AC    DAT 0x81


; hardware

:KEYBOARD dat 0
:MONITOR dat 0
:CLOCK DAT 0

:IOINIT
    hwn i
:map_hardware
    sub I, 1
    hwq I
    ife B, 0x7349
        ife A, 0xF615
            set [MONITOR], I
    ife B, 0x30CF
        ife A, 0x7406
            set [KEYBOARD], I
    ife B, 0x12d0
        Ife A, 0xb402
            set [CLOCK], I
    ife A, 0x12d0
        Ife B, 0xb402
            set [CLOCK], I
    ifn I, 0
        set pc, map_hardware
        
; Next, we set the monitor's screen to  ;
; start at the memory location 
:initialize_monitor
    set A, 0  ; set screen memory
    set B, SCREENMEM
    hwi [MONITOR]
    set A, 3  ; set border
    set B, 9  ; light blue
    hwi [MONITOR]

    JSR MAKE_CBM_FONT
:initialize_keyboard
    SET A, 3
    SET B, KEYINT
    HWI [KEYBOARD]

    RTS

    

:ROMF017    ; RS232-related
            RTS
:ROMF12B    ; print kernal message indexed by Y
            ; send complete address in Y
            IFC [MSGFLG], 0x80 
                JMP ROMF13C
:ROMF12F    SET A, [Y]
            SET PUSH, A
            JSR CHROUT
            ADD Y, 1
            SET A, POP
            IFL A, 0x80
                JMP ROMF12F
:ROMF13C    SET C, 0 ; no error
            RTS
:ROMF1FC    RTS
:DEF_LOAD
:ROMF49E    RTS
:DEF_SAVE
; i forgot the address
        RTS
:DEF_UDTIM
:ROMF69B    RTS
:DEF_RDTIM
:ROMF6DD    RTS
:DEF_SETTIM
:ROMF6E4    RTS
:CINT
:ROMFF5B    RTS
:DEF_GETIN
:ROMF13E    IFN [DFLTN], 0
               JMP ROMF14A
            IFE [NDX], 0    ; if keyboard buffer is blank
               JMP ROMF155 ; return 0
            ; SEI
            JMP ROME5B4

:ROMF14A     IFN [DFLTN], 2 
               JMP ROMF166
             ; insert serial handler here?
             RTS
:ROMF155    ; return blank result for getin
            SET C, 0
            SET A, 0
            SET Z, 1
            RTS

; input a character
; if keyboard: get line, and then return
; characters one at a time

:DEF_CHRIN
:ROMF157   IFN [DFLTN], 0
             JMP ROMF166
           ; record current position of cursor as
           ; start of input on the screen.
           SET [LXSP+1], [PNTR] ; column 
           SET [LXSP], [TBLX]   ; row  
           JMP ROME632

:ROMF166   IFN [DFLTN], 3
               JMP ROMF173
           SET [CRSW], 3
           SET [INDX], [LNMX]
           JMP ROME632 ; input a character from screen

:ROMF173   IFG [DFLTN], 3 ; C64 serial bus device
               JMP ROMF1AD 
           ; ... omitted cassette and RS232 code
           RTS

:ROMF1AD   ;IFE [RAM90], 0
           ;    JMP ROMEE13 ; Read byte from serial bus
           SET A, CBM_RETURN ; CR?
       SET EX, 0
       RTS


; output a character
; stub: always output to screen
:DEF_CHROUT
:ROMF1CA   IFE [DFLTO], 3
             JMP ROME716
       ;IFL [DFLTO], 3
       ;  JMP ROMEDDD  ; Write byte to serial bus
       ; ...
           RTS

:ROMF208   JSR ROMF017 ; rs232-related
:ROMF20B   JMP ROMF1FC ; also stubbed for now

; set input device
:DEF_CHKIN
:ROMF20E    RTS

; set output device
:DEF_CHKOUT
:ROMF250    RTS

; close a file
:DEF_CLOSE
:ROMF291    RTS

; close all files
:DEF_CLALL
:ROMF32F    RTS

; restore I/O to default devices
:ROMF333    RTS

; open a file
:DEF_OPEN
:ROMF34A    RTS
:ROMF5D2    SET Y, MSG_LOADING
            IFN [RAM93], 0
               SET Y, MSG_VERIFYING
            JMP ROMF12B 

; save ram to a device
; X is an address, A is a pointer.

:ROMF5DD   SET [EAL], X
           SET [RAMC1], [A]
           ;JMP [RAM0332] ;normally F5ED

; standard save ram entry
:ROMF5ED  RTS

; handle messages for loading
:ROMF5AF    IFC [MSGFLG], 0x80
                RTS
            SET Y, MSG_SEARCHING
                JSR ROMF12F
            SET A, [FNLEN]
            IFE A, 0 
                RTS
            SET Y, 17
            JSR ROMF12F
            SET Y, [FNLEN]
            IFE Y, 0
                RTS
:ROMF5C7    SET A, [FNADR+Y]
            JSR CHROUT
            ADD Y, 1
            IFN Y, [FNLEN]
                JMP ROMF5C7
            RTS

; do load/verify message

:MSG_SEARCHING
            .DAT 13, "SEARCHIN", 0xC7
:MSG_LOADING
:ROMF106    .DAT 13, "LOADIN", 0xC7
:MSG_SAVING
:ROMF10E    .DAT 13, "SAVIN", 0xC7
:MSG_VERIFYING
:ROMF116    .DAT 13, "VERIFYIN", 0xC7

; close serial bus device
;:ROMF642  RTS

; check for STOP key (probably ESC)
; return C=1 if STOP key pressed.
:DEF_STOP
:ROMF6ED    SET Z, 0 ; default BNE result
            IFN [RAM91], 0x7F
                JMP ROMF6FA
            JSR ROMFFCC
            SET [RAMC6], A
            SET Z, 1 ; from PLP
:ROMF6FA    SET C, 1
            IFL [RAM91], 0x7F
                SET C, 0
            RTS

; increment real time clock
;:ROMF89B  RTS

; Here are some subroutines that can probably be
; replaced with a single DCPU-16 instruction
; where appropriate.

; move save/load address into $AC/$AD

;:ROMFB8E    SET [SAL], [RAMC1]
;            RTS

; compare $AC/$AD with $AE/$AF

;:ROMFCD1    SET C, 0
;            IFG [SAL], [EAL]
;               SET C, 1
;            RTS
            

; increment $AC/$AD

;:ROMFCDB    ADD [SAL], 1
;            RTS

; RESET routine  (SYS 64738)

:ROMFCE2       SET SP, STACKEND-1
               ; omitted cartridge code at FCE7 and FD02
; initialize display, keyboard and clock
:ROMFCF2      JSR IOINIT 
:ROMFCF5      JSR RAMTAS 
              JSR RESTOR 
              JSR CINT   
              IAQ 0 ;CLI
              JMP [ROMA000]  ; START BASIC              

; restore I/O vectors
; this isn't necessary because the I/O vectors are assembled in
; but this part should be ported if anyone wants to do any 
; hardcore IO-level kernal porting.
:RESTOR
:ROMFD15    SET X, ROMFD30
            SET C, 0
            ; TODO: loop through all vectors
            SET [RAM0314], [ROMFD30]
            ;  Create a clock interrupt
            :add_clock
            set a, 0   ; activate clock interrupt
            set b, 1   ; frequency - every frame
            hwi [CLOCK]    
            set a, 2  ; set interrupt mesage
            set b, [clock_interrupt_message]
            hwi [CLOCK]  ; set the interrupt message
            ias MASTER_INT   ; set the interrupt handler

            RTS
:ROMFD30    DAT ROMEA31 ; IRQ
            DAT ROMFE66 ; BRK
            DAT ROMFE47 ; NMI

:MASTER_INT
:ROMFF48 ; In the original 6502 one,
         ; this routine pushed A, X, and Y before
     ; calling one of the two interrupts.
         ; CLOCKINT uses mostly A/X/Y.
     ; KEYINT uses mostly A/B/C.
     ; the BRK routine at FE6F isn't known
    IFE A, [clock_interrupt_message]
        JMP CLOCKINT
    IFE A, KEYINT
        JMP KEYINT
        ;ignore all others
    RFI

:CLOCKINT
    SET PUSH, EX
    SET PUSH, X
    SET PUSH, Y
    JMP [RAM0314]
:clock_interrupt_message
        DAT ROMEA31


; make a custom vector
; i should probably port this
:VECTOR
:ROMFD1A    RTS

; initalise memory pointers
;
:RAMTAS
:ROMFD50
; the original 6502 kernal cleared pages 0, 2, and 3.
; but there's no RAM-ROM distinction so we don't have
; to do this for the DCPU port.
; also skipping the RAM test.
            SET [RAMB2], RAM033C   ; 828...cassette buffer?
            ;JSR ROMFE2D
            SET [RAM0281], BASICMEM
            SET [HIBASE], SCREENMEM
:ROMFD9A    RTS

:SETNAM
:ROMFFBD
:ROMFDF9    SET [FNLEN], A
            SET [FNADR], X
            RTS
; get IO status?
:ROMFE07
        SET A, 0
        RTS

; control kernal messages
:SETMSG
:ROMFF90
:ROMFE18    SET [MSGFLG], A
            SET A, [STATUS]
; add A bits to ST
            BOR [STATUS], A
            RTS

; read/set top of memory
:MEMTOP
:ROMFF99
:ROMFE25   IFN C, 0 ; write if carry bit set
           SET X, [RAM0283]
           SET [RAM0283], X
           RTS

; read/set bottom of memory
:MEMBOT
:ROMFF9C
:ROMFE34   IFN C, 0 ; write if carry bit set
           SET X, [MEMSTR]
           SET [MEMSTR], X  
           RTS

; NMI entry stub
:ROMFE43   ; SEI
           JMP [RAM0318]

; Standard NMI routine stub
:ROMFE47   ;???
           RFI

; BRK routine

:ROMFE66     JSR RESTOR
:ROMFE69     JSR IOINIT
:ROMFE6C     JSR ROME518 ; initialize screen and keyboard
:ROMFE6F     JMP [ROMA002]

; skipping a lot of file i/o-related kernal for now

:ROMFFB7    JMP ROMFE07
:OPEN
:ROMFFC0  JMP [RAM031A]   ; (F34A) open a file
:CLOSE
:ROMFFC3  JMP [RAM031C]   ; (F291) close a file
:CHKIN
:ROMFFC6  JMP [RAM031E]   ; (F20E) set input device
:CHKOUT
:ROMFFC9  JMP [RAM0320]   ; (F250) set output device
:CLRCHN
:ROMFFCC  JMP [RAM0322]   ; (F333) restore I/O devices to default
:CHRIN
:ROMFFCF  JMP [ICHRIN]   ; (F157) input char on current device
:CHROUT
:ROMFFD2  JMP [ICHROUT]   ; (F1CA) output char on current device
:LOAD
:ROMFFD5  JMP DEF_LOAD      ; load RAM from device
:SAVE
:ROMFFD8  JMP DEF_SAVE      ; save RAM to device
:SETTIM
:ROMFFDB  JMP DEF_SETTIM      ; set real time clock
:RDTIM
:ROMFFDE  JMP ROMF6DD      ; read real time clock
:STOP
:ROMFFE1  JMP [ISTOP]    ; (F6ED) check stop key
:GETIN
:ROMFFE4  JMP [IGETIN]    ; (F13E) get a character
:CLALL
:ROMFFE7  JMP [ICLALL]    ; (F32F) close all channels and files
:UDTIM
:ROMFFEA  JMP DEF_UDTIM   ; increment real time clock
:SCREEN
:ROMFFED  JMP DEF_SCREEN  ; read organisation of screen into XY
:PLOT
:ROMFFF0  JMP DEF_PLOT   ; read/set XY cursor position
:IOBASE
:ROMFFF3    JMP DEF_IOBASE  ; read base address of I/O devices
    
:ROMFFFA    DAT ROMFE43   ; NMI vector
:ROMFFFC  DAT ROMFCE2    ; RESET vector
:ROMFFFE  DAT ROMFF48     ; BRK vector


:MAKE_CBM_FONT
    SET A, 4 ; DUMP FONT
    SET B, VISFONT  ; visible font area
    HWI [MONITOR]
    SET A, 3 ; border color
    SET B, 14 ; light blue
    HWI [MONITOR]
    SET A, 2 ; MAKE VISIBLE CUSTOM PALETTE
    SET B, CBM_PALETTE
    HWI [MONITOR]
    SET A, 1 ; MAKE VISIBLE CUSTOM FONT
    SET B, VISFONT  ; visible font area
    HWI [MONITOR]
; Copy XOR map that changes uppercase to lowercase
    SET I, VISFONT+130 ; Location of letter A
    SET J, FONTXOR1
:FONTLOOP0
    SET A, [I]
    XOR A, [I+64]
    STI [J], A
    IFL J, FONTXOR1+52
       SET PC, FONTLOOP0
; copy characters 64-95 to 0-31,
; and characters 96-127.
    SET I, VISFONT
    SET J, 0
:FONTLOOP1
    SET [I], [I+128]   ; Copy lowercase to top 32
    SET [I+128], [J+UPCGFX]   ; Copy lowercase to 64-range
    STI [I+192], [J+COMGFX]  ; Copy C= graphics into 
    IFL I, VISFONT+64
        SET PC, FONTLOOP1
; Copy XOR map that changes uppercase to graphics
    SET I, VISFONT+2 ; Location of letter A
    SET J, FONTXOR2
:FONTLOOP2
    SET A, [I]
    XOR A, [I+128]
    STI [J], A
    IFL J, FONTXOR2+52
       SET PC, FONTLOOP2
    IFE STARTLOWER, 1
        JSR TOGGLEFONT
    RTS

:TOGGLEFONT
; toggle the character set onse
; there's probably an optimal way to do this
; to reduce risk of fire.
    SET I, 0
:TOGGLELOOP
    XOR [I+VISFONT+2], [I+FONTXOR1]
    XOR [I+VISFONT+130], [I+FONTXOR2]
    ADD I, 1
    IFL I, 52
        SET PC, TOGGLELOOP

:TOUPPER
    SET I, 0
    IFE VISFONT+130, 0x587F
        JMP TOGGLELOOP
    RTS
:TOLOWER
    SET I, 0
    IFE VISFONT+130, 0x587F
        JMP TOGGLELOOP
    RTS

:VISFONT    
    .FILL 256 0
:COMGFX
    DAT 0, 0  ; shift-space
    DAT 0xFFFF, 0x00 ; left block
    DAT 0xF0F0, 0xF0F0 ; bottom block
    dat 0x0101, 0x0101 ; top pixel across
    DAT 0x8080, 0x8080 ; bottom pixel across
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0x33CC, 0x33CC ; checkerboard
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x30C0, 0x30C0 ; bottom checkerboard
    DAT 0xFF3F, 0x0F03 ; top left half diagonal
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x00FF, 0x1818 ; box drawing: up down right
    DAT 0x0000, 0xF0F0 ; bottom right quadrant
    DAT 0x001F, 0x1818 ; box drawing: up right
    DAT 0x1818, 0xF800 ; box drawing: down left
    DAT 0xC0C0, 0xC0C0
    DAT 0x00F8, 0x1818
    DAT 0x181F, 0x1818
    DAT 0x18F8, 0x1818
    DAT 0x18FF, 0x0000
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0xFF00, 0x00 ; left 25%
    DAT 0x0000, 0x00FF ; right 25%
    DAT 0x0303, 0x0303 ; top 25%
    DAT 0x0707, 0x0707
    DAT 0xE0E0, 0xE0E0
    DAT 0xC0C0, 0xC0FF
    DAT 0xF0F0, 0x0000
    DAT 0x0000, 0x0F0F
    DAT 0x181F, 0x0000
    DAT 0x0F0F, 0x0000
    DAT 0x0F0F, 0xF0F0
; Uppercase graphics
:UPCGFX
    DAT 0x1818, 0x1818
    DAT 0x587F, 0x5800
    DAT 0x00FF, 0 ; Petscii vertical bar
    DAT 0x1818, 0x1818 ; Petscii horiz bar
    DAT 0x0C0C, 0x0C0C ;
    DAT 0x0606, 0x0606 ; E
    DAT 0x3030, 0x3030 ;F
    DAT 0x00FF, 0x0000 ;G
    DAT 0x0000, 0xFF00 ;H
    DAT 0x18F0, 0x0000 ;I
    DAT 0x000F, 0x1818 ;J
    DAT 0x180F, 0x0000 ;K
    DAT 0xFFC0, 0xC0C0 ;L
    DAT 0x030C, 0x30C0 ;M
    DAT 0xC030, 0x0C03 ;N
    DAT 0xFF03, 0x0303 ;O
    DAT 0x0303, 0x03FF ;P
    DAT 0x3C7E, 0x3C00 ;Q
    DAT 0x6060, 0x6060 ;R
    DAT 0x1F7E, 0x1F00 ;S
    DAT 0xFF00, 0 ;T
    DAT 0x00F0, 0x1818 ;U
    DAT 0xC33C, 0x3CC3 ;V
    DAT 0x3C66, 0x3C00 ;W
    DAT 0x4C73, 0x4C00 ;X
    DAT 0, 0xFF00 ;Y
    DAT 0x1C7F, 0x1C00 ;Z
    DAT 0x18FF, 0x1818; cross
    DAT 0x33CC, 0 ; \
    DAT 0x00FF, 0 ; Petscii vertical bar
    DAT 0x7C04, 0x7C00 ; ^
    DAT 0x0003, 0x0F3F ; _
:ARROWGFX
    DAT 0x0C7F, 0x0C00 ; up arrow
    DAT 0x183C, 0x1818 ; left arrow
    
; XOR masks to toggle uppercase-lowercase
:FONTXOR1
    .FILL 52 0
; XOR masks to toggle graphics-uppercase 
:FONTXOR2
    .FILL 52 0          

; Handle keyboard interrupts by storing keystrokes in
; special RAM locations, where they'll be picked up by 
; the clock interrupt.
:KEYASCII .DAT 0

; 0x01: shift
; 0x05: control
; this doesn't work on any known implementation yet
:KEYSHIFT .DAT 0

:KEYINT
    SET PUSH, B
    SET PUSH, C
    SET A, 2 ; check key
    SET B, DCPU_CTRL
    HWI [KEYBOARD]
	SHL C, 2  
	SET [KEYSHIFT], C
    SET A, 2 ; check key
    SET B, DCPU_SHIFT
    HWI [KEYBOARD]
    BOR [KEYSHIFT], C
    SET A, 1  ; get from queue
    HWI [KEYBOARD]
    SET [DEBUGINT+4], C
    BOR [DEBUGINT+4], 0xA200
    IFL C, 0x90
        SET [KEYASCII], C ; for scanning during clock interrupt
    ;SET A, 2 ; check key
    ;SET B, [KEYASCII] ; original key
    ;; check for key-up event here
    ;HWI [KEYBOARD]
    ;IFE C, 0
    ;    SET [KEYASCII], 0
    SET C, POP
    SET B, POP
    RFI

:CBM_PALETTE
    DAT 0x000, 0xfff, 0xf00, 0x0ff
    DAT 0xf0f, 0x0f0, 0x00f, 0xff0
    DAT 0xf80, 0x840, 0xf88, 0x444
    DAT 0x888, 0x8f8, 0x88f, 0xccc

:BASCRASH
    SET A, [TXTTAB+1]
    SET B, [TXTTAB+2]
    SET C, [TXTTAB+3]
    SET X, [TXTTAB+4]
    SET Y, [TXTTAB+5]
    SET Z, [TXTTAB+6]
    SET I, [TXTTAB+7]
    SET J, [TXTTAB+8]
	SET EX, [TXTTAB+9]
	DAT 0x2400
	    
:VARTABCRASH
    SET A, [VARTAB]
    SET B, [STREND]
    
; jump here if assertion fails
:CRASH DAT 0x3000

:BASICMEM     
        .FILL 10 0 
