;----------------
;  KERNAL MAIN
;----------------

; I used to use a FILL here but this made the hex dump too
; large to paste into web forms.
.DEFINE BASICMEMEND BASICMEM+38912

; PETSCII constants
.DEFINE CBM_STOP 0x03
.DEFINE CBM_RETURN 0x0D
.DEFINE CBM_DELETE 0x14
.DEFINE CBM_INSERT 0x94
.DEFINE CBM_UP 0x91
.DEFINE CBM_DOWN 0x11
.DEFINE CBM_LEFT 0x9D
.DEFINE CBM_RIGHT 0x1D
.DEFINE CBM_HOME 0x13
.DEFINE CBM_CLR 0x93
.DEFINE CBM_SPACE 0x20
.DEFINE CBM_QUOTE 0x22
.DEFINE CBM_COMMA 0x2C
.DEFINE CBM_COLON 0x3A
.DEFINE CBM_RUN 0x83


:ROMA000    DAT ROME394     ; Vector for starting BASIC
:ROMA002    DAT ROME37B

; C64 RAM equivalents
;

.INCLUDE "basic.dasm16"
.INCLUDE "keyboard.dasm16"
.INCLUDE "screen.dasm16"


:RAM90
:STATUS DAT 0
:RAM9D
:MSGFLG DAT 0           


:RAM93  
:VERCK  DAT 0
:RAM97
:XSAV   DAT 0
:RAM99  
:DFLTN  DAT 0
:RAM9A  
:DFLTO  DAT 3
:RAMCA  DAT 0
:RAMCB ; Code of Current Key Pressed
:SFDX   DAT 0
:RAMD0 ; Input from Keyboard (0) or Screen (3)
:CRSW   DAT 0
:RAMAC  
:SAL    DAT 0
:RAMAE  
:EAL    DAT 0
:RAMB2  DAT 0
:RAMC1  DAT 0
; Filename and length
:RAMB7
:FNLEN  DAT 0
:RAMBB
:FNADR  DAT 0

; another floating point conversion thingy
:BASZPT 
:RAMFF DAT 0

;------

; This block of 256 bytes had the same function as the 6502 stack.
:STACK         
              .FILL 256 32
:STACKBASEND
                .FILL 6 32
:STACKEND

:RAM0281 
:MEMSTR   ; Start of memory, only used once
        DAT BASICMEM
:RAM0283  ; End of memory found by RAMTAS
        DAT BASICMEMEND
:RAM0285 ; ???
        DAT 0
:RAM0289
:XMAS   DAT 10
:RAM0291
:MODE       DAT 0
:RAM0292
:AUTODN     DAT 0
; Temporary index to the next line for screen scrolling
:RAM02A5    DAT 0

; IRQ
:RAM0314    DAT ROMEA31
:RAM0316    DAT 0
:IIOBASE
:RAM0318    DAT ROME500
:IOPEN
:RAM031A    DAT DEF_OPEN
:ICLOSE
:RAM031C    DAT DEF_CLOSE
:ICHKIN
:RAM031E    DAT DEF_CHKIN
:ICHKOUT
:RAM0320    DAT DEF_CHKOUT
:ISOMETHING
:RAM0322    DAT ROMF333
:ICHRIN
:RAM0324    DAT DEF_CHRIN
:ICHROUT
:RAM0326    DAT DEF_CHROUT
:ISTOP
:RAM0328    DAT DEF_STOP
:IGETIN 
:RAM032A    DAT DEF_GETIN
:ICLALL  
:RAM032C    DAT DEF_CLALL
:RAM033C    DAT 0

; Error handler for IO calls
:ROME0F9    IFN A, 0xF0
                JMP ROME104
            ; 0xF0 is a special error?
            SET [MEMSIZ], X
            JMP ROMA663
:ROME104    IFE X, 0
                SET X, 0x1E   ; BREAK
            JMP ERROR

; CHROUT plus error checking for BASIC
; (treats EX as error flag, X as error number)
:ROME10C    JSR CHROUT
            IFN EX, 0 ; carry bit set
                JMP ROME0F9
            RTS
:ROME112    JSR CHRIN
            IFG EX, 0
                JMP ROME0F9
            RTS
:ROME118    JSR ROME4AD
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME11E    JSR CHKIN
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME124    JSR GETIN
            IFG C, 0
                JMP ROME0F9
            RTS
            
:ROME4AD
            SET PUSH, A
            JSR ROMFFC9
            SET  X, A
            SET A, POP
            IFE C, 0
                RTS
            SET A, X
            RTS


; normal IRQ interrupt
:IRQ_HANDLER
:ROMEA31    
    ;SET [DEBUGINT+0], [RAMCD]
    ;BOR [DEBUGINT+0], 0xC400
    ;SET [DEBUGINT+1], [RAM028C]
    ;BOR [DEBUGINT+1], 0xC000
    ;SET [DEBUGINT+2], [RAM028B]
    ;BOR [DEBUGINT+2], 0xC000
            ;JSR ROMFFEA ; do clock
            IFN [BLNSW], 0
                JMP ROMEA61
            ; FLASH CURSOR
            SUB [BLNCT], 1
            IFN [BLNCT], 0
                JMP ROMEA61
            SET [BLNCT], BLINK_FRAMES
            XOR [BLNON], 1  ; was last blink on/off?
            SET A, [PNTR] ; CURSOR POSITION
            ADD A, [PNT]
            IFE [BLNON], 0  ; last blink was off
                JMP ROMEA5C
            SET [GDBLN], [A] ; store chr under cursor
            ;JSR ROMEA24
            SET Y, [COLOR]
            SET X, Y
            AND Y, 0x0F00
            SHL Y, 4
            AND X, 0xF000
            SHR X, 4
            BOR X, Y
            AND [A], 0xFF   ; blink on-phase
            BOR [A], X
            IFE A, -1 ; SKIP
:ROMEA5C    SET [A], [GDBLN] ; blink off-phase
:ROMEA61    ; check cassette?
:ROMEA7B    JSR ROMEA87 ; scan keyboard
            SET Y, POP
            SET X, POP
            SET EX, POP
            RFI

; I appropriated this to display another
; chunk of memory in the status bar.
:DISPLAY_LINK_TABLE
        SET PUSH, I
        SET PUSH, J
        SET I, LDTB1
        SET J, DEBUGLNK-1
:LINKLOOP
        STI X, [I]
        SET [J], 0x192E
        IFC X, DL_UNLINKED
            SET [J], 0x1921
        IFL I, LDTB1+HW_ROWS+3
        JMP LINKLOOP
        SET J, POP
        SET I, POP
        RTS

:HEXTHING
   .FILL 10 48
   .FILL 6 -9
:DISPLAY_KEY_DEBUG
        ; debugging code to display some registers every frame
        SET Y, [COUNT]  ; 
        SET X, DEBUGKEY+9
        SET PUSH, B
:DBGLOOP
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+5
           JMP DBGLOOP
        ; another one
        SUB X, 1
        SET Y, [VARTAB]
        ;SET [Y], 0x41
:DBGLOOP2
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+0
           JMP DBGLOOP2
        SET B, POP

:ROME37B    RTS

:DEF_IOBASE
:ROME500    RTS


; In CBM BASIC, this was copied to 0073.
; In DCPU-16, I'm just defining this address
; because there's a BASIC variable fetch routine
; that inexplicably used this address as some
; kind of comparison.
:INITAT
:ROME3A2    dat 0x9000

:INIT
:ROME3BF
            SET A, 0x4C ; ? 
            SET [USRPOK], A
            SET [RAM0311], FCERR
            SET [RAM05], GIVAYF
            SET [RAM03], ROMB1AA
            ; skipped code that copies CHRGET/CHRGOT
            SET [FOUR6], 2  ; single string descriptor
            SET [BITS], 0
            SET [CHANNL], 0
            SET [LASTPT], 0
            ; TODO: figure out why we're doing this
            ; with the stack
            ;SET [RAM01FD], 1
            ;SET [RAM01FC], 1
            SET [TEMPPT], TEMPST ; string stack to beginning
            SET C, 1
            SET B, 123
            JSR MEMBOT
            ; Set [TXTTAB] to beginning of BASIC area
            SET [TXTTAB], X
            SET B, 0xFFFF
            SET C, 1
            JSR MEMTOP
            SET [MEMSIZ], X
            SET [FREETOP], X
            SET Y, [TXTTAB]
            SET [Y], 0
            ADD [TXTTAB], 1
            RTS   ; 0x4B1?

    ; PRINT BASIC STARTUP MESSAGES
:ROME422
            SET A, [TXTTAB]
            JSR REASON
            SET A, ROME473  ; COMMODORE 64 BASIC V2
            JSR STROUT
            ; Calculate number of basic bytes free
            SET A, [MEMSIZ]
            SUB A, [TXTTAB]
            JSR LINPRT
            SET A, WORDS  ; BASIC BYTES FREE
            JSR STROUT
            ; prefill keyboard buffer with 
            JSR RUN_TEST_STRING
            ; go to READY prompt
            JMP ROMA644  ; NEW statement.
            
; startup messages

:WORDS      DAT " BASIC BYTES FREE"
            DAT CBM_RETURN, 0
:ROME473    DAT CBM_CLR ;to clear the screen
            DAT 0x99, "DCPU BASIC ALPHA 0307"
            DAT 0x9A
            DAT CBM_RETURN
            DAT 0
:ROME4AC    DAT 0x81


; DCPU hardware

:KEYBOARD dat 0
:MONITOR dat 0
:CLOCK DAT 0

:IOINIT
    hwn i
:map_hardware
    sub I, 1
    hwq I
    ife B, 0x7349
        ife A, 0xF615
            set [MONITOR], I
    ife B, 0x30CF
        ife A, 0x7406
            set [KEYBOARD], I
    ife B, 0x12d0
        Ife A, 0xb402
            set [CLOCK], I
    ife A, 0x12d0
        Ife B, 0xb402
            set [CLOCK], I
    ifn I, 0
        set pc, map_hardware
        
; Next, we set the monitor's screen to  ;
; start at the memory location 
:initialize_monitor
    set A, 0  ; set screen memory
    set B, SCREENMEM
    hwi [MONITOR]

    JSR MAKE_CBM_FONT
    set A, 3  ; set border
    set B, 0xE  ; light blue
    hwi [MONITOR]

:initialize_keyboard
    SET A, 3
    SET B, KEYINT
    HWI [KEYBOARD]

    RTS

    

:ROMF017    ; RS232-related
            RTS
:ROMF12B    ; print kernal message indexed by Y
            ; send complete address in Y
            IFC [MSGFLG], 0x80 
                JMP ROMF13C
:ROMF12F    SET A, [Y]
            SET PUSH, A
            JSR CHROUT
            ADD Y, 1
            SET A, POP
            IFL A, 0x80
                JMP ROMF12F
:ROMF13C    SET C, 0 ; no error
            RTS
:ROMF1FC    RTS
:DEF_LOAD
:ROMF49E    RTS
:DEF_SAVE
; i forgot the address
        RTS
:DEF_UDTIM
:ROMF69B    RTS
:DEF_RDTIM
:ROMF6DD    RTS
:DEF_SETTIM
:ROMF6E4    RTS
:CINT
:ROMFF5B    RTS
:DEF_GETIN
:ROMF13E    IFN [DFLTN], 0
               JMP ROMF14A
            IFE [NDX], 0    ; if keyboard buffer is blank
               JMP ROMF155 ; return 0
            ; SEI
            JMP ROME5B4

:ROMF14A     IFN [DFLTN], 2 
               JMP ROMF166
             ; insert serial handler here?
             RTS
:ROMF155    ; return blank result for getin
            SET C, 0
            SET A, 0
            SET Z, 1
            RTS

; input a character
; if keyboard: get line, and then return
; characters one at a time

:DEF_CHRIN
:ROMF157   IFN [DFLTN], 0
             JMP ROMF166
           ; record current position of cursor as
           ; start of input on the screen.
           SET [LXSP+1], [PNTR] ; column 
           SET [LXSP], [TBLX]   ; row  
           JMP ROME632

:ROMF166   IFN [DFLTN], 3
               JMP ROMF173
           SET [CRSW], 3
           SET [INDX], [LNMX]
           JMP ROME632 ; input a character from screen

:ROMF173   IFG [DFLTN], 3 ; C64 serial bus device
               JMP ROMF1AD 
           ; ... omitted cassette and RS232 code
           RTS

:ROMF1AD   ;IFE [RAM90], 0
           ;    JMP ROMEE13 ; Read byte from serial bus
           SET A, CBM_RETURN ; CR?
       SET EX, 0
       RTS


; output a character
; stub: always output to screen
:DEF_CHROUT
:ROMF1CA   IFE [DFLTO], 3
             JMP ROME716
       ;IFL [DFLTO], 3
       ;  JMP ROMEDDD  ; Write byte to serial bus
       ; ...
           RTS

:ROMF208   JSR ROMF017 ; rs232-related
:ROMF20B   JMP ROMF1FC ; also stubbed for now

; set input device
:DEF_CHKIN
:ROMF20E    RTS

; set output device
:DEF_CHKOUT
:ROMF250    RTS

; close a file
:DEF_CLOSE
:ROMF291    RTS

; close all files
:DEF_CLALL
:ROMF32F    RTS

; restore I/O to default devices
:ROMF333    RTS

; open a file
:DEF_OPEN
:ROMF34A    RTS
:ROMF5D2    SET Y, MSG_LOADING
            IFN [RAM93], 0
               SET Y, MSG_VERIFYING
            JMP ROMF12B 

; save ram to a device
; X is an address, A is a pointer.

:ROMF5DD   SET [EAL], X
           SET [RAMC1], [A]
           ;JMP [RAM0332] ;normally F5ED

; standard save ram entry
:ROMF5ED  RTS

; handle messages for loading
:ROMF5AF    IFC [MSGFLG], 0x80
                RTS
            SET Y, MSG_SEARCHING
                JSR ROMF12F
            SET A, [FNLEN]
            IFE A, 0 
                RTS
            SET Y, 17
            JSR ROMF12F
            SET Y, [FNLEN]
            IFE Y, 0
                RTS
:ROMF5C7    SET A, [FNADR+Y]
            JSR CHROUT
            ADD Y, 1
            IFN Y, [FNLEN]
                JMP ROMF5C7
            RTS

; do load/verify message

:MSG_SEARCHING
            .DAT 13, "SEARCHIN", 0xC7
:MSG_LOADING
:ROMF106    .DAT 13, "LOADIN", 0xC7
:MSG_SAVING
:ROMF10E    .DAT 13, "SAVIN", 0xC7
:MSG_VERIFYING
:ROMF116    .DAT 13, "VERIFYIN", 0xC7

; close serial bus device
;:ROMF642  RTS

; increment real time clock
;:ROMF89B  RTS

; Here are some subroutines that can probably be
; replaced with a single DCPU-16 instruction
; where appropriate.

; move save/load address into $AC/$AD

;:ROMFB8E    SET [SAL], [RAMC1]
;            RTS

; compare $AC/$AD with $AE/$AF

;:ROMFCD1    SET C, 0
;            IFG [SAL], [EAL]
;               SET C, 1
;            RTS
            

; increment $AC/$AD

;:ROMFCDB    ADD [SAL], 1
;            RTS

; RESET routine  (SYS 64738)

:ROMFCE2       SET SP, STACKEND-1
               ; omitted cartridge code at FCE7 and FD02
; initialize display, keyboard and clock
:ROMFCF2      JSR IOINIT 
:ROMFCF5      JSR RAMTAS 
              JSR RESTOR 
              JSR CINT   
              IAQ 0 ;CLI
              JMP [ROMA000]  ; START BASIC              

; restore I/O vectors
; this isn't necessary because the I/O vectors are assembled in
; but this part should be ported if anyone wants to do any 
; hardcore IO-level kernal porting.
:RESTOR
:ROMFD15    SET X, ROMFD30
            SET C, 0
            ; TODO: loop through all vectors
            SET [RAM0314], [ROMFD30]
            ;  Create a clock interrupt
            :add_clock
            set a, 0   ; activate clock interrupt
            set b, 1   ; frequency - every frame
            hwi [CLOCK]    
            set a, 2  ; set interrupt mesage
            set b, [clock_interrupt_message]
            hwi [CLOCK]  ; set the interrupt message
            ias MASTER_INT   ; set the interrupt handler

            RTS
:ROMFD30    DAT ROMEA31 ; IRQ
            DAT ROMFE66 ; BRK
            DAT ROMFE47 ; NMI

:MASTER_INT
:ROMFF48 ; In the original 6502 one,
         ; this routine pushed A, X, and Y before
     ; calling one of the two interrupts.
         ; CLOCKINT uses mostly A/X/Y.
     ; KEYINT uses mostly A/B/C.
     ; the BRK routine at FE6F isn't known
    IFE A, [clock_interrupt_message]
        JMP CLOCKINT
    IFE A, KEYINT
        JMP KEYINT
        ;ignore all others
    RFI

:CLOCKINT
    SET PUSH, EX
    SET PUSH, X
    SET PUSH, Y
    JMP [RAM0314]
:clock_interrupt_message
        DAT ROMEA31


; make a custom vector
; i should probably port this
:VECTOR
:ROMFD1A    RTS

; initalise memory pointers
;
:RAMTAS
:ROMFD50
; the original 6502 kernal cleared pages 0, 2, and 3.
; but there's no RAM-ROM distinction so we don't have
; to do this for the DCPU port.
; also skipping the RAM test.
            SET [RAMB2], RAM033C   ; 828...cassette buffer?
            ;JSR ROMFE2D
            SET [RAM0281], BASICMEM
            SET [HIBASE], SCREENMEM
:ROMFD9A    RTS

:SETNAM
:ROMFFBD
:ROMFDF9    SET [FNLEN], A
            SET [FNADR], X
            RTS
; get IO status?
:ROMFE07
        SET A, 0
        RTS

; control kernal messages
:SETMSG
:ROMFF90
:ROMFE18    SET [MSGFLG], A
            SET A, [STATUS]
; add A bits to ST
            BOR [STATUS], A
            RTS

; read/set top of memory
:MEMTOP
:ROMFF99
:ROMFE25   IFN C, 0 ; write if carry bit set
           SET X, [RAM0283]
           SET [RAM0283], X
           RTS

; read/set bottom of memory
:MEMBOT
:ROMFF9C
:ROMFE34   IFN C, 0 ; write if carry bit set
           SET X, [MEMSTR]
           SET [MEMSTR], X  
           RTS

; NMI entry stub
:ROMFE43   ; SEI
           JMP [RAM0318]

; Standard NMI routine stub
:ROMFE47   ;???
           RFI

; BRK routine

:ROMFE66     JSR RESTOR
:ROMFE69     JSR IOINIT
:ROMFE6C     JSR ROME518 ; initialize screen and keyboard
:ROMFE6F     JMP [ROMA002]

; skipping a lot of file i/o-related kernal for now

:ROMFFB7    JMP ROMFE07
:OPEN
:ROMFFC0  JMP [RAM031A]   ; (F34A) open a file
:CLOSE
:ROMFFC3  JMP [RAM031C]   ; (F291) close a file
:CHKIN
:ROMFFC6  JMP [RAM031E]   ; (F20E) set input device
:CHKOUT
:ROMFFC9  JMP [RAM0320]   ; (F250) set output device
:CLRCHN
:ROMFFCC  JMP [RAM0322]   ; (F333) restore I/O devices to default
:CHRIN
:ROMFFCF  JMP [ICHRIN]   ; (F157) input char on current device
:CHROUT
:ROMFFD2  JMP [ICHROUT]   ; (F1CA) output char on current device
:LOAD
:ROMFFD5  JMP DEF_LOAD      ; load RAM from device
:SAVE
:ROMFFD8  JMP DEF_SAVE      ; save RAM to device
:SETTIM
:ROMFFDB  JMP DEF_SETTIM      ; set real time clock
:RDTIM
:ROMFFDE  JMP ROMF6DD      ; read real time clock
:STOP
:ROMFFE1  JMP [ISTOP]    ; (F6ED) check stop key
:GETIN
:ROMFFE4  JMP [IGETIN]    ; (F13E) get a character
:CLALL
:ROMFFE7  JMP [ICLALL]    ; (F32F) close all channels and files
:UDTIM
:ROMFFEA  JMP DEF_UDTIM   ; increment real time clock
:SCREEN
:ROMFFED  JMP DEF_SCREEN  ; read organisation of screen into XY
:PLOT
:ROMFFF0  JMP DEF_PLOT   ; read/set XY cursor position
:IOBASE
:ROMFFF3    JMP DEF_IOBASE  ; read base address of I/O devices
    
:ROMFFFA    DAT ROMFE43   ; NMI vector
:ROMFFFC  DAT ROMFCE2    ; RESET vector
:ROMFFFE  DAT ROMFF48     ; BRK vector

; jump points for if assertion fails
:BASCRASH
    SET A, [TXTTAB+1]
    SET B, [TXTTAB+2]
    SET C, [TXTTAB+3]
    SET X, [TXTTAB+4]
    SET Y, [TXTTAB+5]
    SET Z, [TXTTAB+6]
    SET I, [TXTTAB+7]
    SET J, [TXTTAB+8]
	SET EX, [TXTTAB+9]
	DAT 0x2400
	    
:VARTABCRASH
    SET A, [VARTAB]
    SET B, [STREND]
    
:CRASH DAT 0x3000

:BASICMEM     
        .FILL 10 0 

