;----------------
;  KERNAL MAIN
;----------------

; I used to use a FILL here but this made the hex dump too
; large to paste into web forms.
.DEFINE BASICMEMEND BASICMEM+38912

; PETSCII constants
.DEFINE CBM_STOP 0x03
.DEFINE CBM_RETURN 0x0D
.DEFINE CBM_DELETE 0x14
.DEFINE CBM_INSERT 0x94
.DEFINE CBM_UP 0x91
.DEFINE CBM_DOWN 0x11
.DEFINE CBM_LEFT 0x9D
.DEFINE CBM_RIGHT 0x1D
.DEFINE CBM_HOME 0x13
.DEFINE CBM_CLR 0x93
.DEFINE CBM_SPACE 0x20
.DEFINE CBM_QUOTE 0x22
.DEFINE CBM_COMMA 0x2C
.DEFINE CBM_COLON 0x3A
.DEFINE CBM_RUN 0x83


:ROMA000    DAT ROME394     ; Vector for starting BASIC
:ROMA002    DAT ROME37B

; C64 RAM equivalents
;

.INCLUDE "basic.dasm16"
.INCLUDE "keyboard.dasm16"
.INCLUDE "screen.dasm16"

:RAM90
:STATUS DAT 0
:RAM9D
:MSGFLG DAT 0           


:RAM93  
:VERCK  DAT 0
:RAM97
:XSAV   DAT 0
:RAM99  
:DFLTN  DAT 0
:RAM9A  
:DFLTO  DAT 3

:RAMAC  
:SAL    DAT 0
:RAMAE  
:EAL    DAT 0
; scroll pointer
:SCPNT  DAT 0
:RAMB2  DAT 0
:RAMC1  DAT 0
; Filename and length
:RAMB7
:FNLEN  DAT 0
:RAMBB
:FNADR  DAT 0

; keyboard memory
;
; Keyboard Decode Table
:KEYTAB 
:RAMF5 DAT 0

; another floating point conversion thingy
:BASZPT 
:RAMFF DAT 0

;------

; This block of 256 bytes had the same function as the 6502 stack.
; Notable differences include:
;    originally, GOSUB pushed 5 bytes on the stack; now it pushes 3.
:STACK         
              .FILL 256 32
:STACKBASEND
                .FILL 6 32
:STACKEND


:RAM0277    ;KEYBOARD BUFFER
:KEYD
    .FILL KEYBOARD_BUFFER_SIZE 32

:RAM01FB  DAT 0
:RAM01FC  DAT 0
:RAM01FD  DAT 0
:RAM01FE  DAT 0
:RAM01FF  DAT 0
:RAM0200  ; String buffer?
    .FILL BASIC_BUFFER_LENGTH 0
:RAM0281 
:MEMSTR   ; Start of memory, only used once
        DAT BASICMEM
:RAM0283  ; End of memory found by RAMTAS
        DAT BASICMEMEND
:RAM0285 ; ???
        DAT 0

:RAM0289
:XMAS   DAT 10
:RAM0291
:MODE       DAT 0
:RAM0292
:AUTODN     DAT 0
; Temporary index to the next line for screen scrolling
:RAM02A5    DAT 0

; BASIC Indirect Vector Table
; if you guys want to port the DOS wedge go ahead
:RAM0300
:IERROR     DAT DEF_ERROR
:RAM0302
:IMAIN      DAT DEF_MAIN
:RAM0304
:ICRNCH     DAT DEF_CRUNCH    ; crunch tokens
:RAM0306
:IQPLOP     DAT DEF_QPLOP    ; print tokens
:RAM0308
:IGONE      DAT GONE        ; execute statement?
:RAM030A
:IEVAL      DAT DEF_EVAL
:RAM030C    DAT 0
; IRQ
:RAM0314    DAT ROMEA31
:RAM0316    DAT 0
:IIOBASE
:RAM0318    DAT ROME500
:IOPEN
:RAM031A    DAT DEF_OPEN
:ICLOSE
:RAM031C    DAT DEF_CLOSE
:ICHKIN
:RAM031E    DAT DEF_CHKIN
:ICHKOUT
:RAM0320    DAT DEF_CHKOUT
:ISOMETHING
:RAM0322    DAT ROMF333
:ICHRIN
:RAM0324    DAT DEF_CHRIN
:ICHROUT
:RAM0326    DAT DEF_CHROUT
:ISTOP
:RAM0328    DAT DEF_STOP
:IGETIN 
:RAM032A    DAT DEF_GETIN
:ICLALL  
:RAM032C    DAT DEF_CLALL
:RAM033C    DAT 0

; TODO: use preprocessor to hide all the debugging code
; when HW_ROWS >= 12.

; Error handler for IO calls
:ROME0F9    IFN A, 0xF0
                JMP ROME104
            ; 0xF0 is a special error?
            SET [MEMSIZ], X
            JMP ROMA663
:ROME104    IFE X, 0
                SET X, 0x1E   ; BREAK
            JMP ERROR

; CHROUT plus error checking for BASIC
; (treats EX as error flag, X as error number)
:ROME10C    JSR CHROUT
            IFN EX, 0 ; carry bit set
                JMP ROME0F9
            RTS
:ROME112    JSR CHRIN
            IFG EX, 0
                JMP ROME0F9
            RTS
:ROME118    JSR ROME4AD
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME11E    JSR CHKIN
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME124    JSR GETIN
            IFG C, 0
                JMP ROME0F9
            RTS
            
:ROME4AD
            SET PUSH, A
            JSR ROMFFC9
            SET  X, A
            SET A, POP
            IFE C, 0
                RTS
            SET A, X
            RTS


; normal IRQ interrupt
:IRQ_HANDLER
:ROMEA31    
    ;SET [DEBUGINT+0], [RAMCD]
    ;BOR [DEBUGINT+0], 0xC400
    ;SET [DEBUGINT+1], [RAM028C]
    ;BOR [DEBUGINT+1], 0xC000
    ;SET [DEBUGINT+2], [RAM028B]
    ;BOR [DEBUGINT+2], 0xC000
            ;JSR ROMFFEA ; do clock
            IFN [BLNSW], 0
                JMP ROMEA61
            ; FLASH CURSOR
            SUB [BLNCT], 1
            IFN [BLNCT], 0
                JMP ROMEA61
            SET [BLNCT], BLINK_FRAMES
            XOR [BLNON], 1  ; was last blink on/off?
            SET A, [PNTR] ; CURSOR POSITION
            ADD A, [PNT]
            IFE [BLNON], 0  ; last blink was off
                JMP ROMEA5C
            SET [GDBLN], [A] ; store chr under cursor
            ;JSR ROMEA24
            SET Y, [COLOR]
            SET X, Y
            AND Y, 0x0F00
            SHL Y, 4
            AND X, 0xF000
            SHR X, 4
            BOR X, Y
            AND [A], 0xFF   ; blink on-phase
            BOR [A], X
            IFE A, -1 ; SKIP
:ROMEA5C    SET [A], [GDBLN] ; blink off-phase
:ROMEA61    ; check cassette?
:ROMEA7B    JSR ROMEA87 ; scan keyboard
            SET Y, POP
            SET X, POP
            SET EX, POP
            RFI

; I appropriated this to display another
; chunk of memory in the status bar.
:DISPLAY_LINK_TABLE
        SET PUSH, I
        SET PUSH, J
        SET I, LDTB1
        SET J, DEBUGLNK-1
:LINKLOOP
        STI X, [I]
        SET [J], 0x192E
        IFC X, DL_UNLINKED
            SET [J], 0x1921
        IFL I, LDTB1+HW_ROWS+3
        JMP LINKLOOP
        SET J, POP
        SET I, POP
        RTS

:HEXTHING
   .FILL 10 48
   .FILL 6 -9
:DISPLAY_KEY_DEBUG
        ; debugging code to display some registers every frame
        SET Y, [COUNT]  ; 
        SET X, DEBUGKEY+9
        SET PUSH, B
:DBGLOOP
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+5
           JMP DBGLOOP
        ; another one
        SUB X, 1
        SET Y, [VARTAB]
        ;SET [Y], 0x41
:DBGLOOP2
    ; display Y register in hex in debugging line
        SET B, Y
        AND B, 0x0F
        ADD B, [HEXTHING+B]
        SET [X], B
        BOR [X], 0xF000
        DIV Y, 0x10
        SUB X, 1
        IFG X, DEBUGKEY+0
           JMP DBGLOOP2
        SET B, POP

:ROMEAE0 
;Decode the Keystroke and Place its ASCII Value in the Keyboard Buffer


:ROMEB48    ;Set up proper keyboard decode table
            RTS
; load/run for RUN key

:ROMEC44    IFN A, 0x0E ; Lowercase code
                JMP ROMEC4F
            ; TODO: FINISH
:ROMEC4F    IFN A, 0x8E ; Uppercase code
                JMP ROMEC5E
            ; TODO: FINISH
            
; SHIFT-C= KEY CHECK
:ROMEC5E
    ; TODO: FINISH
            JMP ROME6A8
       
            
; KERNAL STUBS
:ROME37B    RTS

:DEF_IOBASE
:ROME500    RTS
; initialize screen and keyboard
:ROME518    
            ;JSR ROME5A0 ; initialize VIC chip - skip
            SET [MODE], 0
            SET [BLNON], 0   
            SET [RAM028F], ROMEB48
            SET [BLNCT], 12
            SET [BLNSW], 12
            SET [XMAS], 10
            SET [RAM028A], 10
            SET [COLOR], 0xE600 ; lt blue on blue
            SET [RAM028C], REPEAT_FRAMES_A   ; key repeat speed
            SET [RAM028B], REPEAT_FRAMES_B   ; key repeat speed
:ROME544    ; Initialize screen link table
            ; and clear the screen.  The 16-bit
            ; version doesn't need to attach
            ; the high byte of memory to this.
            SET I, LDTB1
            SET J, 0
:LINCLRLOOP STI I, DL_UNLINKED ; DISCONNECTED
            IFN J, HW_ROWS+1
                JMP LINCLRLOOP
            SET I, -1 
            SET X, HW_ROWS-1 ; ?
:ROME560    JSR ROME9FF  ; clear one screen line
            SUB X, 1
            IFA X, -1 ; BPL
                JMP ROME560
:ROME566
            SET [PNTR], 0 ; column 0
            SET [TBLX], 0 ; row 0
; set address of current screen line
:ROME56C
            SET X, [TBLX]
:ROME570    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME57C
            ; this is 32 characters further
            ; in the previous line
            ADD [PNTR], HW_COLS
            SUB X, 1
            IFA X, -1
                JMP ROME570
:ROME57C    JSR ROME9F0 ; set PNT line pointer
            SET A, HW_COLS-1
            ADD X, 1
:ROME582    SET Y, [X+LDTB1]
            IFB Y, DL_UNLINKED
                JMP ROME58C
            ADD A, HW_COLS
            ADD X, 1
            JMP ROME582
:ROME58C    SET [LNMX], A ; maximum line length
            ;JMP ROMEA24
            RTS
:ROME591    IFN X, [LXSP]
                RTS
            JMP ROME6ED ; find beginning of logical line
:LP2       ; get a character from the keyboard buffer
:ROME5B4    SET Y, [KEYD] 
            SET X, 0
:ROME5B9    SET [KEYD+X], [KEYD+1+X]
            ADD X, 1
            IFN X, [NDX]
               JMP ROME5B9
            SUB [NDX], 1
            SET A, Y
            IAQ 0
            SET EX, 0
            RTS
; WAIT FOR RETURN FOR KEYBOARD
:ROME5CA    JSR ROME716 ; output to the screen
:ROME5CD    SET A, [NDX]
            SET [BLNSW], A  ; only blink if buffer is empty
            SET [AUTODN], A ; Don't scroll until buffer is empty
            IAQ 0 ; the c64 didn't have to manually enable ints here
            IFE A, 0
                JMP ROME5CD ; Loop until something changes?
:ROME5D6    IAQ 1 ; SEI
            IFE [BLNON], 0
                JMP ROME5E7
            ; restore haracter under cursor
            SET [BLNON], 0
            SET [BLNCT], 2
            SET A, [PNT]
            ADD A, [PNTR]
            SET [A], [GDBLN]
:ROME5E7    JSR ROME5B4 ; get character from buffer
            ;IFN A, CBM_RUN ; RUN key
            ;    JMP ROME5FE
            ; copy LOAD and RUN into buffer
            ;SET X, 9
            ;IAQ 1
            ;SET [NDX], X
:ROME5F3    ;DAT 0x5000
            ;JMP ROME5CD
:ROME5FE    IFN A, CBM_RETURN 
                JMP ROME5CA
            SET Y, [LNMX]
            SET [CRSW], Y
            ADD Y, [PNT]
:ROME606    SET A, [Y]
            AND A, 0xFF
            IFN A, 0x20 ; SPACE
                JMP ROME60F
            SUB Y, 1
            IFN Y, [PNT] ; TODO: fix off-by-one
                JMP ROME606
:ROME60F    ADD Y, 1
            SET [INDX], Y ; mark end of logical line
:ROME612    SET Y, 0
            SET [AUTODN], Y ;temporarily hold scrolling
            SET [PNTR], Y ; beginning of line
            SET [QTSW], Y ; turn off quote mode
            SET A, [LXSP] ; get column at start of input
            IFG [LXSP], 0x7F ; BMI
                JMP ROME63A ; get chr from screen
            SET X, [TBLX]  
:ROME621    JSR ROME591
            IFN X, [LXSP]
                JMP ROME63A  ; get chr from screen
            SET A, [LXSP+1]
            SET [PNTR], A
            IFU A, [INDX]  
                JMP ROME63A  ; get chr from screen
            JMP ROME65D
:ROME632    ; get character from device 0 or 3
            SET PUSH, Y
            SET PUSH, X
            IFE [CRSW], 0
                JMP ROME5CD ; blink cursor, etc
; get character from current screen line
:ROME63A    SET Y, [PNTR]
            ADD Y, [PNT] ; Y <- current character location
            SET A, [Y]   ; A <- current character byte
; TODO: handle RVS text somehow
            AND A, 0xFF
            SET [RAMD7], A
            AND A, 0x3F
            ; TODO: clean up for DCPU-16.
:ROME642    ; we don't need anyu shifting here
            ;SHL [RAMD7], 1
:ROME646    IFC [RAMD7], 0x40  ; original 0x40
                JMP ROME64A
            BOR A, 0x80
:ROME64A    IFC [RAMD7], 0x80         ; original 0x80
                JMP ROME650
            IFN X, [QTSW]
                JMP ROME654
:ROME650    IFB [RAMD7], 0x20   ; ASCII punctuation range
                JMP ROME654    ; leave undisturbed
:ROME652    BOR A, 0x40  ; 
:ROME654    ADD [PNTR], 1
            IFE A, CBM_QUOTE
                XOR [QTSW], 1
:ROME659    IFN Y, [INDX]
                JMP ROME674
:ROME65D    SET [CRSW], 0 ; 
            SET A, CBM_RETURN
            IFE [DFLTN], 3
                JMP ROME66F
            IFE [DFLTO], 3
                JMP ROME672
:ROME66F    JSR ROME716 ; output to the screen
:ROME672    SET A, CBM_RETURN  ; Register EOL
:ROME674    SET [RAMD7], A ; code of final character
            SET X, POP
            SET Y, POP
            IFE A, 0xDE ; screen PI code
                SET A, 0xFF ; petscii PI code
:ROME682    SET EX, 0  ; clc
                SET C, 0
            RTS


; fill screen at current position
:ROME691    BOR A, 0x40
:ROME693    
            SET X, [COLOR]
            IFE [RVS], 0
               JMP ROME699
:ROME697    SET X, [COLOR]
            SHL X, 4
	    SET B, EX
            SHL X, 4
            SET X, EX
            SHL X, 4
            BOR X, B
            SHL X, 8 
            BOR A, 0x80  ; this means "blink" on LEM.
:ROME699    IFN [INSRT], 0
                SUB [INSRT], 1
            ; TODO: proper RVS handling
            JSR ROMEA13 ; place character on screen
            JSR ROME6B6 ; advance cursor

; return from output to the screen
:ROME6A8
            SET J, POP
            SET I, POP
            SET Y, POP
            IFN [INSRT], 0
                SHR [QTSW], 1
            SET X, POP
            SET A, POP
            SET EX, 0
            IAQ 0  ; RE-ENABLE INTERRUPTS
            RTS



;advance the cursor, Get/insert new line
:ROME6B6    JSR ROME8B3 ; move cursor to next line if 
                   ; at end of line -- X will equal old line number
            ADD [PNTR], 1
:ROME6BB    SET A, [LNMX]
            IFL A, [PNTR]
                JMP ROME6C1
            RTS
:ROME6C1            ; this branch is for when you type past the maximum logical line length
            IFE [LNMX], (HW_COLS*ROWS_IN_LINE)-1
                JMP ROME6F7
            IFN [AUTODN], 0  ; if scrolling enabled
                JMP ROME967 ; insert blank line
:ROME6CD    SET X, [TBLX]
            IFL X, HW_ROWS
                JMP ROME6DA ; skip scrolling
            JSR ROME8EA  ; scroll the screen first
            SUB [TBLX], 1
            SET X, [TBLX]
            ; link current line (X) with next line
:ROME6DA    AND [LDTB1+X], 0xFFFF-DL_UNLINKED
            BOR [LDTB1+1+X], DL_UNLINKED
:ROME6E6    ADD [LNMX], HW_COLS
:ROME6ED    IFB [LDTB1+X], DL_UNLINKED
                JMP ROME6F4
            SUB X, 1
            IFN X, 0
                JMP ROME6ED
:ROME6F4    JMP ROME9F0 ; set PNT line pointer to X
:ROME6F7    SUB [TBLX], 1
            JSR ROME87C ; Move cursor to next line
            SET [PNTR], 0 ; beginning of
            RTS
; move backwards over a line boundary
:ROME701    SET X, [TBLX]
        IFN X, 0 ; at top of screen?
                JMP ROME70B
            SET [PNTR], 0 ; ?  column 0
            ;SET A, POP  ; not sure why we pop
            ;SET A, POP
            ;IFN A, 0
                JMP ROME6A8
:ROME70B    SUB X, 1
            SET [TBLX], X
            JSR ROME56C
            SET [PNTR], [LNMX] ; end of line?
            RTS


; In CBM BASIC, this was copied to 0073.
; In DCPU-16, I'm just defining this address
; because there's a BASIC variable fetch routine
; that inexplicably used this address as some
; kind of comparison.
:INITAT
:ROME3A2    dat 0x9000


; DCPU hardware

:KEYBOARD dat 0
:MONITOR dat 0
:CLOCK DAT 0

:IOINIT
    hwn i
:map_hardware
    sub I, 1
    hwq I
    ife B, 0x7349
        ife A, 0xF615
            set [MONITOR], I
    ife B, 0x30CF
        ife A, 0x7406
            set [KEYBOARD], I
    ife B, 0x12d0
        Ife A, 0xb402
            set [CLOCK], I
    ife A, 0x12d0
        Ife B, 0xb402
            set [CLOCK], I
    ifn I, 0
        set pc, map_hardware
        
; Next, we set the monitor's screen to  ;
; start at the memory location 
:initialize_monitor
    set A, 0  ; set screen memory
    set B, SCREENMEM
    hwi [MONITOR]

    JSR MAKE_CBM_FONT
    set A, 3  ; set border
    set B, 0xE  ; light blue
    hwi [MONITOR]

:initialize_keyboard
    SET A, 3
    SET B, KEYINT
    HWI [KEYBOARD]

    RTS

    

:ROMF017    ; RS232-related
            RTS
:ROMF12B    ; print kernal message indexed by Y
            ; send complete address in Y
            IFC [MSGFLG], 0x80 
                JMP ROMF13C
:ROMF12F    SET A, [Y]
            SET PUSH, A
            JSR CHROUT
            ADD Y, 1
            SET A, POP
            IFL A, 0x80
                JMP ROMF12F
:ROMF13C    SET C, 0 ; no error
            RTS
:ROMF1FC    RTS
:DEF_LOAD
:ROMF49E    RTS
:DEF_SAVE
; i forgot the address
        RTS
:DEF_UDTIM
:ROMF69B    RTS
:DEF_RDTIM
:ROMF6DD    RTS
:DEF_SETTIM
:ROMF6E4    RTS
:CINT
:ROMFF5B    RTS
:DEF_GETIN
:ROMF13E    IFN [DFLTN], 0
               JMP ROMF14A
            IFE [NDX], 0    ; if keyboard buffer is blank
               JMP ROMF155 ; return 0
            ; SEI
            JMP ROME5B4

:ROMF14A     IFN [DFLTN], 2 
               JMP ROMF166
             ; insert serial handler here?
             RTS
:ROMF155    ; return blank result for getin
            SET C, 0
            SET A, 0
            SET Z, 1
            RTS

; input a character
; if keyboard: get line, and then return
; characters one at a time

:DEF_CHRIN
:ROMF157   IFN [DFLTN], 0
             JMP ROMF166
           ; record current position of cursor as
           ; start of input on the screen.
           SET [LXSP+1], [PNTR] ; column 
           SET [LXSP], [TBLX]   ; row  
           JMP ROME632

:ROMF166   IFN [DFLTN], 3
               JMP ROMF173
           SET [CRSW], 3
           SET [INDX], [LNMX]
           JMP ROME632 ; input a character from screen

:ROMF173   IFG [DFLTN], 3 ; C64 serial bus device
               JMP ROMF1AD 
           ; ... omitted cassette and RS232 code
           RTS

:ROMF1AD   ;IFE [RAM90], 0
           ;    JMP ROMEE13 ; Read byte from serial bus
           SET A, CBM_RETURN ; CR?
       SET EX, 0
       RTS


; output a character
; stub: always output to screen
:DEF_CHROUT
:ROMF1CA   IFE [DFLTO], 3
             JMP ROME716
       ;IFL [DFLTO], 3
       ;  JMP ROMEDDD  ; Write byte to serial bus
       ; ...
           RTS

:ROMF208   JSR ROMF017 ; rs232-related
:ROMF20B   JMP ROMF1FC ; also stubbed for now

; set input device
:DEF_CHKIN
:ROMF20E    RTS

; set output device
:DEF_CHKOUT
:ROMF250    RTS

; close a file
:DEF_CLOSE
:ROMF291    RTS

; close all files
:DEF_CLALL
:ROMF32F    RTS

; restore I/O to default devices
:ROMF333    RTS

; open a file
:DEF_OPEN
:ROMF34A    RTS
:ROMF5D2    SET Y, MSG_LOADING
            IFN [RAM93], 0
               SET Y, MSG_VERIFYING
            JMP ROMF12B 

; save ram to a device
; X is an address, A is a pointer.

:ROMF5DD   SET [EAL], X
           SET [RAMC1], [A]
           ;JMP [RAM0332] ;normally F5ED

; standard save ram entry
:ROMF5ED  RTS

; handle messages for loading
:ROMF5AF    IFC [MSGFLG], 0x80
                RTS
            SET Y, MSG_SEARCHING
                JSR ROMF12F
            SET A, [FNLEN]
            IFE A, 0 
                RTS
            SET Y, 17
            JSR ROMF12F
            SET Y, [FNLEN]
            IFE Y, 0
                RTS
:ROMF5C7    SET A, [FNADR+Y]
            JSR CHROUT
            ADD Y, 1
            IFN Y, [FNLEN]
                JMP ROMF5C7
            RTS

; do load/verify message

:MSG_SEARCHING
            .DAT 13, "SEARCHIN", 0xC7
:MSG_LOADING
:ROMF106    .DAT 13, "LOADIN", 0xC7
:MSG_SAVING
:ROMF10E    .DAT 13, "SAVIN", 0xC7
:MSG_VERIFYING
:ROMF116    .DAT 13, "VERIFYIN", 0xC7

; close serial bus device
;:ROMF642  RTS

; check for STOP key (probably ESC)
; return C=1 if STOP key pressed.
:DEF_STOP
:ROMF6ED    SET Z, 0
			SET C, 0
            IFN [RAM91], 0x7F
                RTS
            JSR ROMFFCC
            SET [RAMC6], A
            SET C, 1
            SET Z, 1
            RTS

; increment real time clock
;:ROMF89B  RTS

; Here are some subroutines that can probably be
; replaced with a single DCPU-16 instruction
; where appropriate.

; move save/load address into $AC/$AD

;:ROMFB8E    SET [SAL], [RAMC1]
;            RTS

; compare $AC/$AD with $AE/$AF

;:ROMFCD1    SET C, 0
;            IFG [SAL], [EAL]
;               SET C, 1
;            RTS
            

; increment $AC/$AD

;:ROMFCDB    ADD [SAL], 1
;            RTS

; RESET routine  (SYS 64738)

:ROMFCE2       SET SP, STACKEND-1
               ; omitted cartridge code at FCE7 and FD02
; initialize display, keyboard and clock
:ROMFCF2      JSR IOINIT 
:ROMFCF5      JSR RAMTAS 
              JSR RESTOR 
              JSR CINT   
              IAQ 0 ;CLI
              JMP [ROMA000]  ; START BASIC              

; restore I/O vectors
; this isn't necessary because the I/O vectors are assembled in
; but this part should be ported if anyone wants to do any 
; hardcore IO-level kernal porting.
:RESTOR
:ROMFD15    SET X, ROMFD30
            SET C, 0
            ; TODO: loop through all vectors
            SET [RAM0314], [ROMFD30]
            ;  Create a clock interrupt
            :add_clock
            set a, 0   ; activate clock interrupt
            set b, 1   ; frequency - every frame
            hwi [CLOCK]    
            set a, 2  ; set interrupt mesage
            set b, [clock_interrupt_message]
            hwi [CLOCK]  ; set the interrupt message
            ias MASTER_INT   ; set the interrupt handler

            RTS
:ROMFD30    DAT ROMEA31 ; IRQ
            DAT ROMFE66 ; BRK
            DAT ROMFE47 ; NMI

:MASTER_INT
:ROMFF48 ; In the original 6502 one,
         ; this routine pushed A, X, and Y before
     ; calling one of the two interrupts.
         ; CLOCKINT uses mostly A/X/Y.
     ; KEYINT uses mostly A/B/C.
     ; the BRK routine at FE6F isn't known
    IFE A, [clock_interrupt_message]
        JMP CLOCKINT
    IFE A, KEYINT
        JMP KEYINT
        ;ignore all others
    RFI

:CLOCKINT
    SET PUSH, EX
    SET PUSH, X
    SET PUSH, Y
    JMP [RAM0314]
:clock_interrupt_message
        DAT ROMEA31


; make a custom vector
; i should probably port this
:VECTOR
:ROMFD1A    RTS

; initalise memory pointers
;
:RAMTAS
:ROMFD50
; the original 6502 kernal cleared pages 0, 2, and 3.
; but there's no RAM-ROM distinction so we don't have
; to do this for the DCPU port.
; also skipping the RAM test.
            SET [RAMB2], RAM033C   ; 828...cassette buffer?
            ;JSR ROMFE2D
            SET [RAM0281], BASICMEM
            SET [HIBASE], SCREENMEM
:ROMFD9A    RTS

:SETNAM
:ROMFFBD
:ROMFDF9    SET [FNLEN], A
            SET [FNADR], X
            RTS
; get IO status?
:ROMFE07
        SET A, 0
        RTS

; control kernal messages
:SETMSG
:ROMFF90
:ROMFE18    SET [MSGFLG], A
            SET A, [STATUS]
; add A bits to ST
            BOR [STATUS], A
            RTS

; read/set top of memory
:MEMTOP
:ROMFF99
:ROMFE25   IFN C, 0 ; write if carry bit set
           SET X, [RAM0283]
           SET [RAM0283], X
           RTS

; read/set bottom of memory
:MEMBOT
:ROMFF9C
:ROMFE34   IFN C, 0 ; write if carry bit set
           SET X, [MEMSTR]
           SET [MEMSTR], X  
           RTS

; NMI entry stub
:ROMFE43   ; SEI
           JMP [RAM0318]

; Standard NMI routine stub
:ROMFE47   ;???
           RFI

; BRK routine

:ROMFE66     JSR RESTOR
:ROMFE69     JSR IOINIT
:ROMFE6C     JSR ROME518 ; initialize screen and keyboard
:ROMFE6F     JMP [ROMA002]

; skipping a lot of file i/o-related kernal for now

:ROMFFB7    JMP ROMFE07
:OPEN
:ROMFFC0  JMP [RAM031A]   ; (F34A) open a file
:CLOSE
:ROMFFC3  JMP [RAM031C]   ; (F291) close a file
:CHKIN
:ROMFFC6  JMP [RAM031E]   ; (F20E) set input device
:CHKOUT
:ROMFFC9  JMP [RAM0320]   ; (F250) set output device
:CLRCHN
:ROMFFCC  JMP [RAM0322]   ; (F333) restore I/O devices to default
:CHRIN
:ROMFFCF  JMP [ICHRIN]   ; (F157) input char on current device
:CHROUT
:ROMFFD2  JMP [ICHROUT]   ; (F1CA) output char on current device
:LOAD
:ROMFFD5  JMP DEF_LOAD      ; load RAM from device
:SAVE
:ROMFFD8  JMP DEF_SAVE      ; save RAM to device
:SETTIM
:ROMFFDB  JMP DEF_SETTIM      ; set real time clock
:RDTIM
:ROMFFDE  JMP ROMF6DD      ; read real time clock
:STOP
:ROMFFE1  JMP [ISTOP]    ; (F6ED) check stop key
:GETIN
:ROMFFE4  JMP [IGETIN]    ; (F13E) get a character
:CLALL
:ROMFFE7  JMP [ICLALL]    ; (F32F) close all channels and files
:UDTIM
:ROMFFEA  JMP DEF_UDTIM   ; increment real time clock
:SCREEN
:ROMFFED  JMP DEF_SCREEN  ; read organisation of screen into XY
:PLOT
:ROMFFF0  JMP DEF_PLOT   ; read/set XY cursor position
:IOBASE
:ROMFFF3    JMP DEF_IOBASE  ; read base address of I/O devices
    
:ROMFFFA    DAT ROMFE43   ; NMI vector
:ROMFFFC  DAT ROMFCE2    ; RESET vector
:ROMFFFE  DAT ROMFF48     ; BRK vector

; jump points for if assertion fails
:BASCRASH
    SET A, [TXTTAB+1]
    SET B, [TXTTAB+2]
    SET C, [TXTTAB+3]
    SET X, [TXTTAB+4]
    SET Y, [TXTTAB+5]
    SET Z, [TXTTAB+6]
    SET I, [TXTTAB+7]
    SET J, [TXTTAB+8]
	SET EX, [TXTTAB+9]
	DAT 0x2400
	    
:VARTABCRASH
    SET A, [VARTAB]
    SET B, [STREND]
    
:CRASH DAT 0x3000

:BASICMEM     
        .FILL 10 0 

