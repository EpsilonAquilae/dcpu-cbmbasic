:RAM03  
:ADRAY1 DAT 0
:RAM05  
:ADRAY2 DAT 0
:RAM07
:CHARAC DAT 0
:RAM08
:ENDCHR DAT 0
:RAM09  ; Column position of cursor before last TAB or SPC
:TRMPOS DAT 0
:RAM0B
:COUNT  DAT 0
:RAM0C
:DIMFLG DAT 0
:RAM0D
:VALTYP DAT 0
:RAM0E
:INTFLG DAT 0
:RAM0F  ; Flag for LIST, Garbage Collection, and Program Tokenization
:GARBFL DAT 0   
:RAM10  ; Flag: Subscript Reference to an Array or User-Defined Function Call
:SUBFLG DAT 0
:RAM11  ; Flag: is data input to GET, READ, or INPUT?
:INPFLG DAT 0
.DEFINE INF_READ 0x98
.DEFINE INF_GET 0x40
.DEFINE INF_INPUT 0x0
:RAM12
:TANSGN DAT 0
:RAM13 ; Current logical file number
:CHANNL DAT 0
:RAM14  ; Line Number for LIST/GOTO, memory address for PEEK/POKE/SYS
:LINNUM DAT 0
:RAM16  ; Pointer to the next available space in the temporary string stack
:TEMPPT DAT TEMPST
:RAM17  ; Pointer to the address of the last string in the temporary string stack
:LASTPT DAT 0
:RAM18  DAT 0
:RAM19 ; Descriptor stack for temporary strings
:TEMPST
    .FILL 10 0
:TEMPSTEND
:RAM22
:INDEX  DAT 0, 0
:RESHO ; multiplication argument - mantissa only
:RAM26  DAT 0
:RAM27  DAT 0, 0
; Pointer to the start of BASIC program text
:RAM2B  
:TXTTAB DAT BASICMEM+1

:RAM4A DAT 0
; Pointer to the variable storage area
:RAM2D
:VARTAB DAT 0
; Pointer to the start of the array storage area
:RAM2F
:ARYTAB DAT 0
; Pointer to the start of free RAM
:RAM31
:STREND DAT 0
:RAM33
:FREETOP    DAT 0
; Temporary Pointer for Strings
:RAM35
:FRESPC DAT 0
:RAM37 ; Pointer to highest address used by basic
:MEMSIZ DAT 0
;Current basic line number (>0xF00 in immediate mode)
:RAM39
:CURLIN DAT 0
:RAM3B
:OLDLIN DAT 0
:RAM3D
:OLDTXT DAT 0
:RAM3F
:DATLIN DAT 0
:RAM41
:DATPTR DAT 0
:RAM43
:INPPTR DAT 0
:RAM45  
:VARNAM DAT 0, 0
:RAM47
:VARPNT DAT 0
:RAM49
:FORPNT DAT 0
:RAM4B
:OPPTR  DAT 0
:RAM4D
:OPMASK DAT 0
.DEFINE OPM_LT 1
.DEFINE OPM_EQ 2
.DEFINE OPM_GT 4
:RAM4E
:DEFPNT DAT 0
;temporary pointer to the current string descriptor
:RAM50
:DSCPNT DAT 0
:FOUR6
:RAM53  DAT 0
:RAM55  DAT 0
:RAM57  DAT 0, 0, 0
; additional floating point registers
:RAM58 DAT 0
:RAM5A DAT 0
:RAM5C  DAT 0, 0, 0
:RAM5D 
:DECEXP DAT 0 ; decimal exponent during FIN/FOUT
:RAM5E  DAT 0 ; Number of digits during FIN?
:RAM5F  DAT 0 ; ...
:RAM60  DAT 0 ; sign of exponent operator in FIN
:FAC1    ; Floating Point Accumulato0r 
:RAM61   ; Exponent (only 8 bits used)
:FACEXP DAT 0
:RAM62   ; Mantissa (32-bit)
:FACHO DAT 0
:RAM64 DAT 0
:FACSGN
:RAM66 DAT 0

:RAM67 ; Number of terms in a series evaluation
       ; OR, a sign flag somewhere in FIN.
:SGNFLG  DAT 0

:RAM68 ; FAC 1 Overflow during conversions
:BITS   DAT 0

    DAT 0x1111
:FAC2
:ARG     ; Floating Point Argument
:RAM69   ; Exponent (only 8 bits used)
:ARGEXP DAT 0
:RAM6A   ; Mantissa (32-bit)
:ARGHO  DAT 0, 0
:ARGOV
:RAM56  DAT 0
:ARGSGN
:RAM6E  DAT 0
:ARISGN ; Result of signed comparison
:RAM6F  DAT 0
:FACOV  ;low order mantissa byte for rounding
:RAM70  DAT 0
:FBUFPT ; Series Evaluation Pointer
:RAM71  DAT 0

;  CHRGET: Move BASIC's execution cursor (RAM7A) to next character,
;                 then
;  CHRGOT: Read character at execution cursor into A
;  A=0 for end of line, 0 < A <= 0x7F for ASCII literals,
;  A>=0x80 for BASIC tokens
;  C=0 for digits, C=1 for all other characters
;  Z=1 for end of statement (i.e. null or ASCII colon)
;  A contains the character fetched.
:CHRGET
:RAM0073    ADD [RAM7A], 1
:CHRGOT
:RAM0079    DAT 0x7801 ;SET A, [next word]
:RAM7A      DAT 0x0800 
            AND A, 0xFF  ; BASIC statements are still 8-bit
            SET C, 1
            SET Z, 0
            IFE A, CBM_COLON
                SET Z, 1  ; return Z=1 for end of statement
            IFG A, 0x39  ; Not a digit or space
                RTS      ; return C=1
:RAM0080    IFE A, CBM_SPACE ; Space
            JMP CHRGET  ; skip to next character
            SET C, 0
            IFL A, 0x30  ; Is a digit
:RAM008C        SET C, 1 ; C=1, is not a digit
            IFE A, 0
:RAM008Z        SET Z, 1
            RTS

.DEFINE TXTPTR RAM7A

:USRPOK
:RAM0310    JMP 1234
.DEFINE RAM0311 USRPOK+1
.DEFINE USRADD USRPOK+1

; ************* BASIC ROM ************


; some special tokens
.DEFINE BASIC_FOR_TOKEN 0x81
.DEFINE BASIC_TO_TOKEN 0xA4
.DEFINE BASIC_STEP_TOKEN 0xA9
.DEFINE BASIC_DATA_TOKEN 0x83
.DEFINE BASIC_GOSUB_TOKEN 0x8D
.DEFINE BASIC_REM_TOKEN 0x8F
.DEFINE BASIC_PRINT_TOKEN 0x99
.DEFINE BASIC_GOTO_TOKEN 0x89
.DEFINE BASIC_THEN_TOKEN 0xA7
.DEFINE BASIC_TAB_TOKEN 0xA3
.DEFINE BASIC_SPC_TOKEN 0xA6
.DEFINE BASIC_FN_TOKEN 0xA5
.DEFINE BASIC_NOT_TOKEN 0xA8
.DEFINE BASIC_EQ_TOKEN 0xB2
.DEFINE BASIC_LEFT_TOKEN 0xC8
.DEFINE BASIC_SGN_TOKEN 0xB4
.DEFINE BASIC_MINUS_TOKEN 0xAB
.DEFINE BASIC_PLUS_TOKEN 0xAA



; address table for commands
; (In original, address minus 1 used because
;  the 6502 added 1 to the PC after an RTS)

    DAT "CBMBASIC"

:TOKEN_ROUTINES
:ROMA00C
            DAT STMT_END
            DAT STMT_FOR
            DAT STMT_NEXT
            DAT STMT_DATA
            DAT STMT_INPUTN
            DAT STMT_INPUT 
            DAT 0xB080   ; 
            DAT STMT_READ  
            DAT STMT_LET   
            DAT STMT_GOTO  
            DAT STMT_RUN   
            DAT STMT_IF
            DAT STMT_RESTORE   ; restore
            DAT STMT_GOSUB 
            DAT STMT_RETURN
            DAT STMT_REM   
            DAT STMT_STOP  
            DAT STMT_ON
            DAT 0xB82C
            DAT 0xE167
            DAT 0xE155
            DAT 0xE164
            DAT 0xB3B2
            DAT 0xB823
            DAT STMT_PRINTN
            DAT STMT_PRINT
            DAT STMT_CONT
            DAT STMT_LIST
            DAT STMT_CLR
            DAT STMT_CMD
            DAT 0xE129
            DAT 0xE1BD
            DAT 0xE1C6
            DAT 0xAB7A
            DAT STMT_NEW
:FUNCTION_ROUTINES 
            DAT SIGN    ; sgn
            DAT INT     ; int
            DAT ROMBC58 ; abs
            DAT 0x0310  ; usr
            DAT ROMB37D  ; fre
            DAT ROMB39E  ; pos
            DAT 0xBF71  ; sqr
            DAT 0xE097  ; rnd
            DAT 0xB9EA  ; log
            DAT ROMBFED ; exp
            DAT 0xE264  ; cos
            DAT 0xE26B  ; sin
            DAT 0xE2B4  ; tan
            DAT 0xE30E  ; atn
            DAT 0xB80D  ; peek
            DAT ROMB77C  ; len
            DAT STRD
            DAT 0xB7AD
            DAT 0xB78B
            DAT CHRD
            DAT LEFTD
            DAT RIGHTD
            DAT MIDD

; indexing offset
.DEFINE FUNCTION_VECTOR FUNCTION_ROUTINES-BASIC_SGN_TOKEN


; priority and address table
; for operators

:TBL_OP   
        DAT 0x79
        DAT FADDT   ; plus
        DAT 0x79
        DAT FSUBT   ; minus
        DAT 0x7B
        DAT FMULTT  ; multiply
        DAT 0x7B
        DAT FDIVT   ; divide
        DAT 0x7F
        DAT 0xBF7A   ; power
        DAT 0x50
        DAT ROMAFE9   ; AND
        DAT 0x46
        DAT ROMAFE6   ; OR
:TBL_OP_NEG
        DAT 0x7D
        DAT NEGOP   ; negative
:TBL_OP_NOT
        DAT 0x5A
        DAT NOTOP   ; NOT
        DAT 0x64
        DAT 0xB015   ; greater / equal / less


; table of commands
; each ended with a +0x80

:TOKEN_NAMES
:ROMA09E   
        DAT 0x45,0x4E,0xC4   ; end
        DAT 0x46,0x4F,0xD2   ; for
        DAT 0x4E,0x45,0x58,0xD4   ; next
        DAT 0x44,0x41,0x54,0xC1   ; data
        DAT 0x49,0x4E,0x50,0x55,0x54,0xA3   ; input#
        DAT 0x49,0x4E,0x50,0x55,0xD4   ; input
        DAT 0x44,0x49,0xCD   ; dim
        DAT 0x52,0x45,0x41,0xC4   ; read
        DAT 0x4C,0x45,0xD4   ; let
        DAT 0x47,0x4F,0x54,0xCF   ; goto
        DAT 0x52,0x55,0xCE   ; run
        DAT 0x49,0xC6   ; if
        DAT 0x52,0x45,0x53,0x54,0x4F,0x52,0xC5   ; restore
        DAT 0x47,0x4F,0x53,0x55,0xC2   ; gosub
        DAT 0x52,0x45,0x54,0x55,0x52,0xCE   ; return
        DAT 0x52,0x45,0xCD   ; rem
        DAT 0x53,0x54,0x4F,0xD0   ; stop
        DAT 0x4F,0xCE   ; on
        DAT 0x57,0x41,0x49,0xD4   ; wait
        DAT 0x4C,0x4F,0x41,0xC4   ; load
        DAT 0x53,0x41,0x56,0xC5   ; save
        DAT 0x56,0x45,0x52,0x49,0x46,0xD9   ; verify
        DAT 0x44,0x45,0xC6   ; def
        DAT 0x50,0x4F,0x4B,0xC5   ; poke
        DAT 0x50,0x52,0x49,0x4E,0x54,0xA3   ; print#
        DAT 0x50,0x52,0x49,0x4E,0xD4   ; print
        DAT 0x43,0x4F,0x4E,0xD4   ; cont
        DAT 0x4C,0x49,0x53,0xD4   ; list
        DAT 0x43,0x4C,0xD2   ; clr
        DAT 0x43,0x4D,0xC4   ; cmd
        DAT 0x53,0x59,0xD3   ; sys
        DAT 0x4F,0x50,0x45,0xCE   ; open
        DAT 0x43,0x4C,0x4F,0x53,0xC5   ; close
        DAT 0x47,0x45,0xD4   ; get
        DAT 0x4E,0x45,0xD7   ; new

        DAT 0x54,0x41,0x42,0xA8   ; tab(
        DAT 0x54,0xCF   ; to
        DAT 0x46,0xCE   ; fn
        DAT 0x53,0x50,0x43,0xA8   ; spc(
        DAT 0x54,0x48,0x45,0xCE   ; then
        DAT 0x4E,0x4F,0xD4   ; not
        DAT 0x53,0x54,0x45,0xD0   ; step
        DAT 0xAB   ; plus
        DAT 0xAD   ; minus
        DAT 0xAA   ; multiply
        DAT 0xAF   ; divide
        DAT 0xDE   ; power
        DAT 0x41,0x4E,0xC4   ; and
        DAT 0x4F,0xD2   ; or
        DAT 0xBE   ; greater
        DAT 0xBD   ; equal
        DAT 0xBC   ; less
        DAT 0x53,0x47,0xCE   ; sgn
        DAT 0x49,0x4E,0xD4   ; int
        DAT 0x41,0x42,0xD3   ; abs
        DAT 0x55,0x53,0xD2   ; usr
        DAT 0x46,0x52,0xC5   ; fre
        DAT 0x50,0x4F,0xD3   ; pos
        DAT 0x53,0x51,0xD2   ; sqr
        DAT 0x52,0x4E,0xC4   ; rnd
        DAT 0x4C,0x4F,0xC7   ; log
        DAT 0x45,0x58,0xD0   ; exp
        DAT 0x43,0x4F,0xD3   ; cos
        DAT 0x53,0x49,0xCE   ; sin
        DAT 0x54,0x41,0xCE   ; tan
        DAT 0x41,0x54,0xCE   ; atn
        DAT 0x50,0x45,0x45,0xCB   ; peek
        DAT 0x4C,0x45,0xCE   ; len
        DAT 0x53,0x54,0x52,0xA4   ; str$
        DAT 0x56,0x41,0xCC   ; val
        DAT 0x41,0x53,0xC3   ; asc
        DAT 0x43,0x48,0x52,0xA4   ; chr$
        DAT 0x4C,0x45,0x46,0x54,0xA4   ; left$
        DAT 0x52,0x49,0x47,0x48,0x54,0xA4   ; right$
        DAT 0x4D,0x49,0x44,0xA4   ; mid$

; other commands

        DAT 0x47,0xCF   ; go
        DAT 0x00    ; end of list


; table of errors messages
; each ended with a +0x80

:ERR01 ;TOO MANY FILES
   DAT 0x54,0x4F,0x4F
   DAT 0x20,0x4D,0x41,0x4E,0x59
   DAT 0x20,0x46,0x49,0x4C,0x45,0xD3
:ERR02 ;FILE OPEN
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4F,0x50,0x45,0xCE
:ERR03 ;FILE NOT OPEN
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x4F,0x50,0x45,0xCE
:ERR04 ;FILE NOT FOUND
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x46,0x4F,0x55,0x4E,0xC4
:ERR05 ;DEVICE NOT PRESENT
   DAT 0x44,0x45,0x56,0x49,0x43,0x45
   DAT 0x20,0x4E,0x4F,0x54
   DAT 0x20,0x50,0x52,0x45,0x53,0x45,0x4E,0xD4
:ERR06 ;NOT INPUT FILE
   DAT 0x4E,0x4F,0x54
   DAT 0x20,0x49,0x4E,0x50,0x55,0x54
   DAT 0x20,0x46,0x49,0x4C,0xC5
:ERR07 ;NOT OUTPUT FILE
   DAT 0x4E,0x4F,0x54
   DAT 0x20,0x4F,0x55,0x54,0x50,0x55,0x54
   DAT 0x20,0x46,0x49,0x4C,0xC5
:ERR08 ;MISSING FILE NAME
   DAT 0x4D,0x49,0x53,0x53,0x49,0x4E,0x47
   DAT 0x20,0x46,0x49,0x4C,0x45
   DAT 0x20,0x4E,0x41,0x4D,0xC5
:ERR09 ;ILLEGAL DEVICE NUMBER
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x44,0x45,0x56,0x49,0x43,0x45
   DAT 0x20,0x4E,0x55,0x4D,0x42,0x45,0xD2
:ERR0A ;NEXT WITHOUT FOR
   DAT 0x4E,0x45,0x58,0x54
   DAT 0x20,0x57,0x49,0x54,0x48,0x4F,0x55,0x54
   DAT 0x20,0x46,0x4F,0xD2
:ERR0B ;SYNTAX
   DAT 0x53,0x59,0x4E,0x54,0x41,0xD8
:ERR0C ;RETURN WITHOUT GOSUB
   DAT 0x52,0x45,0x54,0x55,0x52,0x4E
   DAT 0x20,0x57,0x49,0x54,0x48,0x4F,0x55,0x54
   DAT 0x20,0x47,0x4F,0x53,0x55,0xC2
:ERR0D ;OUT OF DATA
   DAT 0x4F,0x55,0x54
   DAT 0x20,0x4F,0x46
   DAT 0x20,0x44,0x41,0x54,0xC1
:ERR0E ;ILLEGAL QUANTITY
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x51,0x55,0x41,0x4E,0x54,0x49,0x54,0xD9
:ERR0F ;OVERFLOW
   DAT 0x4F,0x56,0x45,0x52,0x46,0x4C,0x4F,0xD7
:ERR10 ;OUT OF MEMORY
   DAT 0x4F,0x55,0x54
   DAT 0x20,0x4F,0x46
   DAT 0x20,0x4D,0x45,0x4D,0x4F,0x52,0xD9
:ERR11 ;UNDEF'D STATEMENT
   DAT 0x55,0x4E,0x44,0x45,0x46,0x27,0x44
   DAT 0x20,0x53,0x54,0x41,0x54,0x45,0x4D,0x45,0x4E,0xD4
:ERR12 ;BAD SUBSCRIPT
   DAT 0x42,0x41,0x44
   DAT 0x20,0x53,0x55,0x42,0x53,0x43,0x52,0x49,0x50,0xD4
:ERR13 ;REDIM'D ARRAY
   DAT 0x52,0x45,0x44,0x49,0x4D,0x27,0x44
   DAT 0x20,0x41,0x52,0x52,0x41,0xD9
:ERR14 ;DIVIDION BY ZERO
   DAT 0x44,0x49,0x56,0x49,0x53,0x49,0x4F,0x4E
   DAT 0x20,0x42,0x59
   DAT 0x20,0x5A,0x45,0x52,0xCF
:ERR15 ;ILLEGAL DIRECT
   DAT 0x49,0x4C,0x4C,0x45,0x47,0x41,0x4C
   DAT 0x20,0x44,0x49,0x52,0x45,0x43,0xD4
:ERR16 ;TYPE MISMATCH
   DAT 0x54,0x59,0x50,0x45
   DAT 0x20,0x4D,0x49,0x53,0x4D,0x41,0x54,0x43,0xC8
:ERR17 ;STRING TOO LONG
   DAT 0x53,0x54,0x52,0x49,0x4E,0x47
   DAT 0x20,0x54,0x4F,0x4F
   DAT 0x20,0x4C,0x4F,0x4E,0xC7
:ERR18 ;FILE DATA
   DAT 0x46,0x49,0x4C,0x45
   DAT 0x20,0x44,0x41,0x54,0xC1
:ERR19 ;FORMULA TOO COMPLEX
   DAT 0x46,0x4F,0x52,0x4D,0x55,0x4C,0x41
   DAT 0x20,0x54,0x4F,0x4F
   DAT 0x20,0x43,0x4F,0x4D,0x50,0x4C,0x45,0xD8
:ERR1A ;CAN'T CONTINUE
    DAT 0x43,0x41,0x4E,0x27,0x54
    DAT 0x20,0x43,0x4F,0x4E,0x54,0x49,0x4E,0x55,0xC5
:ERR1B ;UNDEF'D FUNCTION
    DAT 0x55,0x4E,0x44,0x45,0x46,0x27,0x44
    DAT 0x20,0x46,0x55,0x4E,0x43,0x54,0x49,0x4F,0xCE
:ERR1C  ;VERIFY
    DAT 0x56,0x45,0x52,0x49,0x46,0xD9
:ERR1D  ;LOAD
    DAT 0x4C,0x4F,0x41,0xC4

; error message address locations

:ROMA326    DAT 0  ; ???
   DAT ERR01   ; 01 too many files
   DAT ERR02   ; 02 file open
   DAT ERR03   ; 03 file not open
   DAT ERR04   ; 04 file not found
   DAT ERR05   ; 05 device not present
   DAT ERR06   ; 06 not input file
   DAT ERR07   ; 07 not output file
   DAT ERR08   ; 08 missing file name
   DAT ERR09   ; 09 illegal device number
   DAT ERR0A   ; 0A next without for
   DAT ERR0B   ; 0B syntax
   DAT ERR0C   ; 0C return without gosub
   DAT ERR0D   ; 0D out of data
   DAT ERR0E   ; 0E illegal quantity
   DAT ERR0F   ; 0F overflow
   DAT ERR10   ; 10 out of memory
   DAT ERR11   ; 11 undef'd statment
   DAT ERR12   ; 12 bad subscript
   DAT ERR13   ; 13 redim'd array
   DAT ERR14   ; 14 devision by zero
   DAT ERR15   ; 15 illegal direct
   DAT ERR16   ; 16 type mismatch
   DAT ERR17   ; 17 string too long
   DAT ERR18   ; 18 file data
   DAT ERR19   ; 19 formula too complex
   DAT ERR1A   ; 1A can't continue
   DAT ERR1B   ; 1B undef'd function
   DAT ERR1C   ; 1C verify
   DAT ERR1D   ; 1D load
   DAT ROMA381   ; 1E break

; other messages

; ok

:ROMA364   DAT CBM_RETURN, "OK", CBM_RETURN
:ROMA368   DAT 0

; error

:ROMA369   DAT "  ERROR"
:ROMA370   DAT 0

; in

:ROMA371   DAT " IN "
:ROMA375   DAT 0

; ready.

:ROMA376   DAT CBM_RETURN, "READY.", CBM_RETURN
:ROMA380   DAT 0

; break

:ROMA381   DAT CBM_RETURN,0x0A

:ROMA383   DAT "BREAK"

:ROMA388   DAT 0x00

:ROMA389   DAT 0xA0


:PEEKSTACK
			SET [0], SP
			SET J, 0
:PEEKLOOP	SET A, [0]
			SET A, [A]
			ADD [0], 1
			ADD J, 1
			JSR LINPRT
			IFL [RAM49], STACKBASEND
				JMP PEEKLOOP
			SET Z, 0
			RTS
			

:FNDFOR
; Search for "FOR" blocks on stack containing
; the current variable.  If found, returns the
; stack location as X, and Z=1.  Otherwise, Z=0
:ROMA38A    SET Z, 0
			SET X, SP
            ADD X, 2 ; make allowance for two JSRs 
:ROMA38F    SET A, [X]
			IFN A, BASIC_FOR_TOKEN ; FOR block
                RTS ; not a FOR block.
:ROMA39A    IFN [FORPNT], 0
				JMP ROMA3A4
			SET [FORPNT], [X+1]
:ROMA3A4	SET A, [X+1]
			IFE [FORPNT], A
				JMP ROMA3B7
:ROMA3B0    ADD X, 11
			JMP ROMA38F
:ROMA3B7    SET Z, 1 ; "found" result
			RTS
			
:DEBUGFORx	SET A, PEEK
			JSR LINPRT
			SET A, PICK 0
			JSR LINPRT
			SET A, PICK 1
			JSR LINPRT
			SET A, PICK 2
			JSR LINPRT
			SET A, PICK 3
			JSR LINPRT
			SET A, PICK 4
			JSR LINPRT
			SET A, PICK 5
			JSR LINPRT
			SET A, 13
			JSR CHROUT
			SET A, BASIC_FOR_TOKEN
			JSR LINPRT
			SET A, 13
			JSR CHROUT
			
:DEBUGFOR	SET Z, 0
			RTS
			

:BLTU
; Parameters in [RAM5F], [RAM5A], and [RAM58]
;               and A should contain the value of [RAM58].
; RETURN: ?
:ROMA3B8        JSR REASON      ; garbage collect?
                SET [STREND], A ; returned start of free RAM
:ROMA3BF        SET B, [RAM5F] ; source start address
                SET J, [RAM5A] ; source end address
                SET I, [RAM58] ; destimation end address
                IFE J, B
                    RTS
:ROMA3BG        STD [I], [J]
                IFN J, B
                    SET PC, ROMA3BG
                RTS
; test for 2 * A bytes free on stack
:GETSTK         
    MUL A, 2
    ADD A, 52
    ADD A, STACK
    IFG A, SP
        JMP ROMA435
    RTS

; array area overflow check
:REASON
:ROMA408    IFL A, [FREETOP]      ; CPY $34
:ROMA40A        RTS       ; BCC $A434
                SET PUSH, A
:ROMA416        SET PUSH, Y
:ROMA41C        JSR GARBAG
:ROMA427        SET Y, POP
:ROMA429        SET A, POP
            ; garbage collection not enough?
:ROMA42A    IFG A, [FREETOP]
                JMP OMERR
:ROMA434    RTS

; out of memory error
:OMERR
:ROMA435     SET X, 16  ; ?OUT OF MEMORY

; handle error messages
:ERROR
:ROMA437     JMP [IERROR]   ; snall detour in the kernal
:BASIC_ERROR
:ROMA43A     SET [INDEX], [ROMA326+X]
:ROMA447     JSR CLRCHN
:ROMA44C     SET [CHANNL], 0
:ROMA44E     JSR ROMAAD7 ; end line on CMD
:ROMA451     JSR ROMAB45
             SET Z, [INDEX]   ; LDY #$00
:ROMA456     SET A, [Z]       ; LDA ($22),Y
             SET PUSH, A      ; PHA
            
            AND A, 0x7F      ; AND #$7F
            SET PUSH, Z
             JSR ROMAB47   ; CHROUT
            SET Z, POP
             ADD Z, 1            ; INY
            SET A, POP 
            IFC A, 0x80       ; PLA
                SET PC, ROMA456  ; BPL $A456
             JSR ROMA67A ; clear some basic variables
             SET A, ROMA369  ; "  ERROR"
:ROMA469     JSR STROUT
             IFL [CURLIN], 0xFF00  ;If not in immediate node
                 JSR ROMBDC2      ; display "IN <line>"

:READY
:ROMA474     SET A, ROMA376   ; "READY."
             JSR STROUT
             SET A, 0x80
:ROMA47D     JSR SETMSG
; main loop
:MAIN
:ROMA480    JMP [IMAIN] ; normally ROMA483
:DEF_MAIN
:ROMA483    
            ; debugging is useful
            IFE DEBUGPROGMEM, 0
                JMP SKIPBMEM
            SET I, SCREENMEM
            SET J, BASICMEM
:BMEMLOOP
            STI [I], [J]
            BOR [I-1], 0x0100
            IFL I, SCREENMEM+32
                JMP BMEMLOOP
:SKIPBMEM
            JSR INLIN ; address of line input in X
            SET [RAM7A], X
:ROMA48A    JSR CHRGET     ; JSR $0073
:ROMA48D    SET X, A ; TAX
:ROMA48E    IFE A, 0  ; BEQ $A480 
                JMP [IMAIN]   ; which was this JMP
            SET [CURLIN], -1 ; enter immediate mode
            IFE C, 0 ; begins with a digit
               JMP MAIN1 ; add line to program
            ; parse statement in immediate mode
            JSR CRUNCH ; token cruncher
            JMP ROMA7E1 ; execute a statement

; handle insert/delete basic lines
:MAIN1
:ROMA49C    JSR LINGET   ; get decimal number into [LINNUM]
            JSR CRUNCH   ; token cruncher
            ; why is this too short?
            SET [COUNT], Y  ; cache length of line
            JSR FINDLN  ; search for line A
            IFE C, 0 ; line number not found
                JMP ROMA4ED  ; insert only
; Delete old line.
:ROMA4A9    SET I, [RAM5F] ; Pointer to matched line
            SET J, [I]     ; Pointer to following line
            STD B, [VARTAB] ; End of program text
            SUB B, J
            ADD B, I       ; End when line is removed.
			SET [VARTAB], B ; reclaim memory for variables
            ; due to the fact that zero is always a 16-bit zero,
            ; and never the high byte of a small number, 
            ; we might be able to relink the program within the
            ; loop instead of the old way.
:ROMA4A9L
            STI [I], [J]
       		IFL I, B
				JMP ROMA4A9L
			SET [I], [J]
; insert new line.
:ROMA4ED    JSR ROMA659 ; clear variable memory
            JSR LINKPRG ; relink basic program
            SET A, [RAM0200]
            IFE A, 0   ; No text entered
                JMP MAIN ; delete only; return to prompt
            ; Make room for new line by moving the rest
            ; of the program up
:ROMA4F8    SET EX, 0xA4F8
            ; sanity check -- something's clearing VARTAB
            IFE [VARTAB], 0
                JMP VARTABCRASH
            SET A, [VARTAB]
            SET [RAM5A], A  ; source end address
            ADD A, [COUNT]  ; add number of characters
            SET [RAM58], A  ; destination end address
            JSR BLTU        ; Move memory
            SET [RAM01FF], [LINNUM]
:ROMA517    SET [VARTAB], [STREND]
            SET Y, [COUNT]
            SUB Y, 1
            ; copy line into memory
            SET I, [RAM5F] ; pointer to new spot in memory
            ADD I, Y
            STI J, RAM01FE
            ADD J, Y
:ROMA522L
            STD [I], [J]
            IFN J, RAM01FE
                JMP ROMA522L
:ROMA52A    JSR ROMA659 ; clr?
            JSR LINKPRG
            JMP [IMAIN]

; relink basic program
:LINKPRG
:ROMA533    
            SET I, [TXTTAB]
            SET J, I   ; note beginning of line
:ROMA53C    IFE [I+1], 0 ; no link; must be end of program
                RTS
            ADD I, 1   ; skip over line number
:ROMA544    ADD I, 1   ; go to next character
            IFN [I], 0
                JMP ROMA544
            ADD I, 1
:ROMA54A    SET [J], I  ; link from beginning of line to current location
:ROMA559    SET J, I    ; use current location for next link
:ROMA55D    JMP ROMA53C 

; Get a line from the console.
; X will be set to the length of the string (1 when blank)
; input stored in RAM0200, zero-terminated
:INLIN
:ROMA560    SET X, 0
:ROMA562    JSR ROME112   ; GETIN -> ROMF157
            IFE A, CBM_RETURN 
                JMP ROMAACA ; mark end and return
            SET [RAM0200+X], A
            ; copy line to top of screen for debugging
            ;SET [SCREENMEM+X], A
            ;AND [SCREENMEM+X], 0x003F
            ;BOR [SCREENMEM+X], 0x5000
            ADD X, 1
            IFL X, HW_COLS*ROWS_IN_LINE
                JMP ROMA562
            SET X, 0x17 ; ?LINE TOO LONG
            JMP ERROR
            
; Standard Token Cruncher
; Throughout this routine, X contains the address
; of the characters being evaluated.
; RAM0F is used to disable tokenization after a DATA statement.
; Y returns the length of the string plus 2, not including line number 
; 2 is added so that when the crunched string is copied into program
; memory, it is copied along with an extra word for the line number,
; and an extra word into which the link to the next line will be stored.
; That is why everything indexed from [RAM01FE] instead of [RAM0200]
; directly, and why everything in the 6502 version indexed from $01FC.
:CRUNCH
:ROMA579    JMP [ICRNCH]
:DEF_CRUNCH
:ROMA57C    SET X, [RAM7A] 
            SET Y, 2    ; first two characters are taken up by link &c
            SET [RAM0F], Y
:ROMA582    SET A, [X]
            IFC A, 0x80  ; BPL, unshifted character.
                JMP ROMA58E
            IFE A, 0xFF ; pi
                JMP ROMA5C9
            ADD X, 1
            JMP ROMA582 ; ignore, go to next
:ROMA58E    IFE A, CBM_SPACE
                JMP ROMA5C9
            SET [ENDCHR], A
            IFE A, CBM_QUOTE
                JMP ROMA5EE ; skip to next quote
            IFB [RAM0F], 0x40 ; BVS
                JMP ROMA5C9 ; Quote mode for DATA statement
            IFN A, 0x3F ; question mark
                JMP ROMA5A4
            SET A, BASIC_PRINT_TOKEN 
            JMP ROMA5C9
            ; the REM test line should get at least this far
:ROMA5A4    IFL A, 0x30 ; Zero
                JMP ROMA5AC ; not a digit
:ROMA5A8    IFL A, 0x3C ; Digit
                JMP ROMA5C9
:ROMA5AC    SET [RAM71], Y  ; cache position in thing
            SET Y, 0
            SET [COUNT], 0
            SUB Y, 1
            SET [RAM7A], X
            SUB X, 1
; Loop through input buffer and token, see if they match.
:ROMA5B6    ADD Y, 1 ; does next character of token table...
            ADD X, 1 ; match the next byte of the input?
; loop section 1
:ROMA5B8    SET A, [X]
:ROMA5BC    SUB A, [TOKEN_NAMES+Y]
            AND A, 0xFF
            IFE A, 0
                JMP ROMA5B6
:ROMA5C1    ; 0x80 matches both the final character of
            ; a full command, or the shifted final character
            ; of an abbreviated command.
            IFN A, 0x80
                JMP ROMA5F5            
            BOR A, [COUNT]  ;untested
:ROMA5C7    SET Y, [RAM71]
:ROMA5C9    ADD X, 1 ; Move to next character in buffer
            ADD Y, 1 ; Move to...?
            SET [RAM01FD+Y], A
            IFE A, 0
                JMP ROMA609
:ROMA5D4    SUB A, CBM_COLON
            IFE A, 0
                JMP ROMA5DC
            IFN A, (BASIC_DATA_TOKEN-CBM_COLON) ; DATA token
                JMP ROMA5DE
:ROMA5DC    SET [RAM0F], A ; Set quote mode ON for DATA
:ROMA5DE    SUB A, (BASIC_REM_TOKEN-CBM_COLON) 
            AND A, 0xFF
            IFN A, 0
                JMP ROMA582 ; just move to next character
            SET [ENDCHR], 0 
            ; Copy characters literally until either
            ; end of line, or whatever's in [ENDCHR].
:ROMA5E5    SET A, [X]
            AND A, 0xFF
            IFE A, 0
                JMP ROMA5C9
:ROMA5EA    IFE A, [ENDCHR]
                JMP ROMA5C9
:ROMA5EE    ADD Y, 1
            SET [RAM01FD+Y], A
            ;SET [RAM0200-3+Y], A
            ADD X, 1
            IFB X, 0xFF ; BNE in 8-bit
                JMP ROMA5E5
            ; Jumped here from string matcher above,
            ; when a token didn't match.  Return to beginning
            ; of token, and try the next one.
:ROMA5F5    SET X, [RAM7A]  ; Restore original source pointer
            ADD [COUNT], 1
            ; Skip past end of this token
:ROMA5F9    ADD Y, 1
:ROMA5FA    IFC [TOKEN_NAMES_1+Y], 0x80
                JMP ROMA5F9
            IFN [TOKEN_NAMES+Y], 0
                JMP ROMA5B8 ; Try next token
:ROMA604    SET A, [X]
            IFC A, 0x80 ; unshifted
                JMP ROMA5C7
            ; branches here if null character found
:ROMA609    SET [RAM01FE+Y], A  ; ends with two NULLs in a row
            ;SET [RAM0200-3+Y], 0
:ROMA60C    SET [RAM7A], RAM0200-1
            RTS

; SEARCH for a line in a program
; pass address of first line to check in A (originally A+X)
; returns C=1 and address in RAM5F if found
; returns C=0 if not found

:FINDLN
:ROMA613    SET A, [TXTTAB]     ; $2B
:FINDLNA
:ROMA617    SET I, 1
:ROMA619    SET [RAM5F], A
            ADD I, [RAM5F]  ; I = NEXT line in linked list
:ROMA61D    SET A, [I] ; get address of that line
            IFE A, 0
                JMP ROMA640
            SET A, [LINNUM]
            IFL A, [I]
                JMP ROMA640 ; return "not found"
            SET C, 1    ;since last one was a BCC
            IFE A, [I]
                RTS    ; return "found"
:ROMA637    SET A, [I-1]
            JMP FINDLNA  ; Check line after next. 
:ROMA640    SET C, 0 ; return "not found"
            RTS
            
; NEW command

:STMT_NEW
:ROMA642    IFE Z, 0
                RTS
:ROMA644    SET I, [TXTTAB]
            STI [I], 0
            STI [I], 0
            SET [I], 0
            SET [VARTAB], I
:ROMA659    JSR ROMA68E ; set execution pointer to [TXTTAB]-1

:ROMA65C    SET A, 0     ;LDA #$00
            SET Z, 1
; CLR command

:STMT_CLR
:ROMA65E    IFE Z, 0
                RTS   ; BNE $A68D            
:ROMA660    JSR CLALL
:ROMA663    SET [FREETOP], [MEMSIZ]
            ;SET EX, 0xA663
            ;IFE [VARTAB], 0
            ;   JMP VARTABCRASH
            SET [ARYTAB], [VARTAB]
            SET [STREND], [VARTAB]  ; set start of free RAM
:ROMA677    JSR STMT_RESTORE

; reset stack and program pointers

:ROMA67A    SET [TEMPPT], TEMPST  ;String pointer stack
            SET A, POP ; Pull RTS location
            SET SP, STACKBASEND  ; LDX #$FA
            SET PUSH, A
            SET [OLDTXT], 0
            SET [SUBFLG], 0
:ROMA68D    RTS

; set current character pointer to start of basic - 1
; return A

:ROMA68E    SET A, [TXTTAB]
            SUB A, 1
            SET [RAM7A], A
            RTS

:STMT_LIST
:ROMA69C    IFE C, 0     ; LIST line
                JMP ROMA6A4
            IFE Z, 1    ; LIST all
                JMP ROMA6A4
            IFN A, BASIC_MINUS_TOKEN ; LIST -end
                RTS
:ROMA6A4    JSR LINGET
            JSR FINDLN ; 
            JSR CHRGOT
            IFE Z, 1  ; no end line specified
                JMP ROMA6BB
            IFN A, BASIC_MINUS_TOKEN  ; range to end
                RTS
            JSR CHRGET
            JSR LINGET
            IFE Z, 0  
                RTS
                ; pop?
:ROMA6BB    SET A, POP
            SET A, POP
            IFN [LINNUM], 0
                JMP ROMA6C9
            SET [LINNUM], -1
; LIST LINES from RAM5F to LINNUM
:ROMA6C9    SET [RAM0F], 1
            SET Y, [RAM5F]
:ROMA6CD    IFE [Y], 0     ; no link to next line
                JMP ROMA714
            JSR ROMA82C ; check STOP key
            JSR ROMAAD7 ; end line on output file
            ADD Y, 1
            IFG [Y], [LINNUM]  ; beyond end line
                JMP ROMA714 ; break out of loop
            SET [FORPNT], Y
:ROMA6EA    SET A, [Y]
            JSR LINPRT
            SET A, CBM_SPACE ; space following line number
:ROMA6EF    SET Y, [FORPNT]
:ROMA6F1    AND A, 0x7F ; filter high bit if coming from QPLOP
            ; loop to print a line
:ROMA6F3    JSR ROMAB47 ; print character
            IFE A, CBM_QUOTE
            BOR [RAM0F], -1 ; enter quote mode
            ADD Y, 1
            ;IFE Y, 0  ; what, stop after 256 characters?
            ;   JMP ROMA714
            SET A, [Y]
            IFN A, 0
                JMP QPLOP ; Print with tokens expanded
            SET Y, [RAM5F] ; follow link to nxt line
            SET [RAM5F], [Y] ; cache link to line after that
            IFN [Y], 0
                JMP ROMA6C9
:ROMA714    JMP ROME386 

; Standard Token Printer
:QPLOP
:ROMA717    JMP [IQPLOP]
:DEF_QPLOP
:ROMA71A    IFL A, 0x80 ; Low ASCII
                JMP ROMA6F3   ; print literal
            IFE A, 0xFF ; PI
                JMP ROMA6F3   ; print literal
            IFB [RAM0F], 0x8000 ; BMI
                JMP ROMA6F3   ; print literal
            ; token value detected
:ROMA724    SUB A, 0x7F
            SET [RAM49], Y
            SET Y, TOKEN_NAMES_1
:ROMA72C    SUB A, 1 ; Next token
            IFE A, 0
                JMP ROMA737
:ROMA72F    ADD Y, 1 ; Next character in token
            IFC [Y], 0x80
                JMP ROMA72F ; Next character
            JMP ROMA72C    ; next token
            ; print keyword
:ROMA737    ADD Y, 1
            SET A, [Y]
            IFB A, 0x80 ; end of token
                JMP ROMA6EF  ; print last character and return to loop
            JSR ROMAB47 ; print character in token
            JMP ROMA737

; FOR statement
; calls STMT_LET and pushes 11 words onto the stack:
;    pointer to first statement in loop      @ 10
;    line number of same                     @ 9
;    TO target as 3-word float               @ 6-8   
;    STEP increment as 4-word float          @ 2-5   
;    pointer to variable being incremented   @ 1   
;    FOR token                               @ 0 - shallow  

:STMT_FOR
:ROMA742	SET [RAM10], 0x80
			JSR STMT_LET
			JSR FNDFOR
			IFE Z, 0 ;
				JMP ROMA753
			; we're already looping on this variable
			ADD X, 10  ; is this right?
			SET SP, X  ; purge that loop from the stack 
:ROMA753	SET A, POP ; discard JSR
			SET A, 11   ; test for this many bytes available
			JSR GETSTK
			JSR ROMA906 ; get end of statement
			SET PUSH, I        ; push first statement in loop ; +1
			SET PUSH, [CURLIN] ; push line number             ; +1
			SET A, BASIC_TO_TOKEN   ; TO token
			JSR SYNCHR
			JSR ROMAD8D  ; left side of TO must be numeric
			JSR FRMNUM   ; get number on right side of TO
			; Compress FACSGN into FACHO;
			; pushing only 3 words.
			SET A, [FACSGN]
			BOR A, 0x7FFF
			AND A, [FACHO]
			SET [FACHO], A
			SET I, ROMA78B  ; return vector
			JMP ROMAE43 ; push TO target value    +3
			; it returns here
:ROMA78B	SET A, FONE ; STEP 1 by default
			JSR MOVFM
			JSR CHRGOT
			IFN A, BASIC_STEP_TOKEN  ; STEP token?
				JMP ROMA79F
			JSR CHRGET
			JSR FRMNUM ; get STEP value
:ROMA79F	JSR SIGN
			JSR ROMAE38  ; push STEP with separate sign byte +4
			SET PUSH, [FORPNT] ; pointer to increment variable +1
			SET PUSH, BASIC_FOR_TOKEN
			;SET A, PEEK
			;SET B, PICK 1
			;SET C, PICK 2
			;DAT 0x0C00

; execute next statement

:NEWSTT
:ROMA7AE    JSR ROMA82C ; check STOP key
:ROMA7B1    ; Skip OLDTXT setting if executed line is in
            ; the RAM0200 range, i.e. in immediate mode
            SET A, [RAM7A]
            IFL A, RAM0200
                JMP ROMA7BA
            IFG A, RAM0200+BASIC_BUFFER_LENGTH-1
                JMP ROMA7BA
            JMP ROMA7BE
            ; set CONT return position
:ROMA7BA    SET [OLDTXT], [RAM7A]
; instead of using Y to index, we store the whole
; address in Z.
:ROMA7BE    SET Z, [RAM7A]
:ROMA7C0    SET A, [Z]
:ROMA7C2    IFN A, 0 ; NOT end of line
              JMP ROMA807 ; consume required colon and continue
:ROMA7C4    SET A, [Z+1] ; check link to next line
:ROMA7C8    SET C, 0  ; hide "BREAK" message
:ROMA7C9    IFE A, 0  ; no line following this one
                JMP ROMA84B   ; end program

:ROMA7CE    ADD Z, 2  ; get new current line number
:ROMA7CF    SET [CURLIN], [Z]
:ROMA7D8    SET [RAM7A], Z
:ROMA7E1    JMP [RAM0308]   ; normally A7E4

:GONE    ; execute a statement
:ROMA7E4    JSR CHRGET    ; get token into A
            JSR ROMA7ED   ; execute command in token
            JMP NEWSTT    ; move to next statement

; execute command  at RAM7A.
; its first character or token is in A
:ROMA7ED    IFN Z, 0  ; If zero bit set
                RTS
:ROMA7EF    SUB A, 0x80
            IFU A, 0   
                JMP STMT_LET ; simple variable assignment
:ROMA7F3    IFG A, 0x22 ; number of commands
                JMP ROMA80E
            SET PUSH, [TOKEN_ROUTINES+A] ; get address of next command
            JMP CHRGET
            ; will return to STMT_* with next character in A, C, Z.
:ROMA807    IFE A, CBM_COLON
                JMP ROMA7E1
            JMP SNERR
            ; handle "GO TO" with a space in it
:ROMA80E    IFN A, 0x4B ; GO code
                JMP SNERR
            JSR CHRGET
            SET A, BASIC_TO_TOKEN   ; TO code
            JSR SYNCHR
            JMP STMT_GOTO

; LET command
:STMT_LET
:ROMA9A5    JSR PTRGET ; get variable from name as Y 
            ; should return an address, and 
            ; leave the cursor before the = sign following
            SET [FORPNT], Y ; assignments use FORPNT instead of VARPNT
            SET A, BASIC_EQ_TOKEN ; equals code
            JSR SYNCHR
            SET PUSH, [INTFLG]
            SET PUSH, [VALTYP]
            JSR FRMEVAL
            SET A, POP ; VALTYP of variable...
            SHL A, 1
            SET C, EX
            JSR ROMAD90  ; check that it's the correct type
			; Z flag was result of BIT $0D
            AND A, [VALTYP]
            IFN A, 0
                JMP ROMA9D9  ; assign to string
:ROMA9C1    SET A, POP  ; INTFLG of variable
:ROMA9C2    IFC A, 0x80 ; BPL
                JMP ROMBBD0  ; assign to float

; assign to integer
:ROMA9C4    JSR ROUND
            JSR AYINT ; convert float to int
            SET [RAM49], [FACHO]
            RTS

;assign to string
:ROMA9D9    SET A, POP ; discard INTFLG from STMT_LET
:ROMA9DA    IFN [RAM49], ROMBF13   ; I think NOTFNS does this
                JMP ROMAA2C
            ;assign to TI$
            JSR ROMB6A6
            IFN A, 6       ; length must be 6
                JMP FCERR  ; otherwise illegal quantity error
            SET Y, 0
            SET [RAM61], 0
            SET [RAM66], 0
:ROMA9ED    SET [RAM71], Y
            JSR ROMAA1D
            JSR MUL10
            ADD [RAM71], 1
            SET Y, [RAM71]
            JSR ROMAA1D
            JSR MOVAF
            SET X, A
            IFE A, 0
                JMP ROMAA07
            ADD X, 1
            SET A, X
            JSR ROMBAED
:ROMAA07    SET Y, [RAM71]
            ADD Y, 1
            IFN Y, 6
                JMP ROMA9ED
            JSR MUL10
            JSR ROMBC9B
            ; this is definitely wrong, but it
            ; should be simple to fix later
            SET X, [RAM64]
            ;SET Y, [RAM62] ; 63
            ;SET A, [RAM65]
            JMP SETTIM

; assign to variable string
:ROMAA2C    ;DAT 0x5000
			SET Y, [RAM64]
			SET A, [Y]
			SET B, [Y+1]
            ;SET C, [FREETOP]
            ;DAT 0x2000
            IFL [Y+1], [FREETOP]; beginning of string variable area
                JMP ROMAA4B ; points to a string already in memory
            IFL Y, [VARTAB] 
                JMP ROMAA4B ; points to a literal in BASIC
            JMP ROMAA52     ; 
:ROMAA4B    SET A, [RAM64] ; take pointer
            JMP ROMAA68    ; move descriptor into variable
:ROMAA52    SET A, [Y]
            JSR ROMB475
            SET [RAM6F], [DSCPNT]  ;TODO: check order
            JSR MOVINS  ; move string
            SET A, FACEXP
; move 3-byte descriptor into variable
:ROMAA68    SET [DSCPNT], A
            JSR FRETMS ; herp derp stack
            SET A, [DSCPNT]
            SET Y, [RAM49]
            SET [Y], [A]
            SET [Y+1], [A+1]
            SET [Y+2], [A+2]
            RTS

; add next digit to float accum

:ROMAA1D    SET A, [INDEX]
            ADD A, Y
            SET A, [A]  ; LDA ($22),Y
            JSR RAM0080 ; verify is digit
            IFN C, 0 ; not a digit
                JMP FCERR
            SUB A, 0x30
:ROMAA29    JMP FINLOG


; end line on CMD output file

:STMT_RESTORE
:ROMA81D    SET A, [TXTTAB]        
            SUB A, 1      
:ROMA827    SET [DATPTR], A 
            RTS
; test STOP key for break in program
:ROMA82C     JSR STOP
; will set carry bit if pressed

; STOP command
; is basically END with the carry bit set,
; so that the BREAK message appears.
:STMT_STOP
:ROMA82F    IFN C, 0      ; BCS $A832
                JMP ROMA832

; END command
:STMT_END
:ROMA831       SET C, 0      ; CLC
:ROMA832       IFE Z, 0     ; Not end of statement
                    RTS
:ROMA834       SET A, [RAM7A]      
:ROMA838       IFG [CURLIN], 0xFF00   ; LDX $3A
:ROMA83A          SET PC, ROMA849  
:ROMA83D       SET [OLDTXT],[RAM7A]  ; STA $3D
:ROMA83F                            ; STY $3E
:ROMA841       SET [OLDLIN],[CURLIN]
:ROMA849       SET A, POP      ; PLA x2

:ROMA84B       SET A, ROMA381 ; "BREAK"
               IFE C, 0 ; not really a break
                  SET PC, ROME386
:ROMA851       JMP ROMA469

:STMT_CONT
:ROMA857    IFE Z, 1
                RTS
            SET X, 0x1A ; ?CAN'T CONTINUE ERROR
            IFL [OLDTXT], 0x100
                SET PC, ERROR 
            SET [RAM7A],[OLDTXT]
            SET [CURLIN],[OLDLIN]   
            RTS

; RUN command

:STMT_RUN
:ROMA871    SET PUSH, Z
            SET A, 0
:ROMA874    JSR SETMSG
:ROMA877    SET Z, POP
:ROMA878    IFN Z, 0 ; Not zero
                JMP ROMA659 ; clear variable memory

:ROMA87D    JSR ROMA660      ; do CLR
:ROMA880    JMP ROMA897      ; do GOTO

; GOSUB command

:STMT_GOSUB
:ROMA883    SET A, 3
            JSR GETSTK    ; check for room in the stack
            ; originally pushed 5 bytes to stack,
            ; now pushes 3 words
            SET PUSH, [RAM7A]
            SET PUSH, [CURLIN]
            SET PUSH, BASIC_GOSUB_TOKEN  ; to signify a GOSUB

:ROMA897    JSR CHRGOT

            JSR STMT_GOTO
            JMP NEWSTT  ; execute next statement

; GOTO command

:STMT_GOTO
:ROMA8A0    JSR LINGET  ; get target line
            JSR ROMA909  ; Set I to the 0 at the end of this line
            SET A, I ; start at next line
            ADD A, 1 ; skip over null 
            IFG [CURLIN], [LINNUM]
                SET A, [TXTTAB] ; start at beginning
            IFE [CURLIN], [LINNUM]
                SET A, [TXTTAB] ; start at beginning
            JSR FINDLNA ; set [RAM5F] to address of target
            IFE C, 0 ; BCC $A8E3
                JMP ROMA8E3 ; throw ?UNDEF'D STATEMENT
:ROMA8C5    SET A, [RAM5F]
            SUB A, 1
:ROMA8C9    SET [RAM7A], A  ; got new location
            RTS

; RETURN command
:STMT_RETURN
:ROMA8D2    IFE Z, 0
                RTS
			BOR [RAM49], 0xFF00 ; in case GOSUB from immediate
			JSR FNDFOR   ; Search for FOR blocks on stack
			SET SP, X
			IFE PEEK, BASIC_GOSUB_TOKEN ; CMP #$8D   ; GOSUB
				JMP ROMA8EB
			SET X, 0x0C  ; ?RETURN WITHOUT GOSUB
            IFN X, 0x0C  ; skip next
:ROMA8E3    SET X, 0x11 ; ?undef'd statment
		        JMP ERROR

; Remove GOSUB block from stack
:ROMA8EB    SET A, POP ; consume GOSUB token
            SET [CURLIN], POP
            SET [RAM7A], POP

:STMT_DATA
:ROMA8F8    JSR ROMA906 ; get end of statement
            ; instead of returning number to add in Y,
            ; returns complete address in I.
:ROMA8FB        SET [RAM7A], I
            RTS

; todo: should the I point to the zero or the
; character after the zero?
; GET END OF LINE
; returns address of next line in I, ready for RAM7A.
; (original returned number to add in Y)
:ROMA906    SET [CHARAC], CBM_COLON   ; get next statement
                JMP ROMA90D
:ROMA909    SET [CHARAC], 0     ; get end of line
:ROMA90D    SET I, [RAM7A]
            SET [ENDCHR], 0
:ROMA911    SET A, [ENDCHR]
            SET X, [CHARAC]
:ROMA915    SET [CHARAC], A
            SET [ENDCHR], X
:ROMA919    SET A, [I] 
            SET Z, 0
            IFE A, 0
                SET Z, 1
            IFE A, 0
                RTS
:ROMA91D    IFE A, 8
                RTS
            ADD I, 1
            IFE A, CBM_QUOTE ; quote mark
                JMP ROMA911
            JMP ROMA919

:STMT_IF
:ROMA928    JSR FRMEVAL
            JSR CHRGOT
            IFE A, BASIC_GOTO_TOKEN
                JMP ROMA937
            SET A, BASIC_THEN_TOKEN
            JSR SYNCHR
:ROMA937    SET C, 0
            SET A, [FACEXP] ; get result of FRMEVAL
            IFN A, 0
                JMP ROMA940

:STMT_REM
:ROMA93B    JSR ROMA909 ; get end of line
            JMP ROMA8FB ; was BEQ

:STMT_THEN
:ROMA940    JSR CHRGOT
            IFN C, 0        ; THEN <command>
                JMP ROMA7ED ; execute command
            JMP STMT_GOTO ; THEN <line number>

:STMT_ON
:ROMA94B    JSR ROMB79E  ; Get result of expression after ON
			;DEBUG CITY USA
			SET PUSH, [RAM64]
			SET PUSH, A
			JSR LINPRT
			SET A, POP
			SET [RAM64], POP
            SET PUSH, A  ; cache token following the expression
            IFE A, BASIC_GOSUB_TOKEN
                JMP ROMA957
:ROMA953    IFN A, BASIC_GOTO_TOKEN
                JMP SNERR
            ; original used $65 -- low byte of a 16-bit, right?
:ROMA957    SUB [RAM64], 1
            IFN [RAM64], 0
                JMP ROMA95F ; skip
            SET A, POP  ; pop GOTO/GOSUB token
            JMP ROMA7EF ; evaluate as if a stand-alone command
:ROMA95F    JSR CHRGET  
            JSR LINGET  ; consume and discard line number
            IFE A, CBM_COMMA
            JMP ROMA957
            SET A, POP ; past end of list; do nothing.
            RTS         

; get decimal number into $14/$15
; C should be zero coming in, and
; A should be the result of a CHRGET.
; throws an illegal quantity error if over 63999.

:LINGET
:ROMA96B    SET X, 0
            SET [LINNUM], 0
:ROMA971    IFN C, 0
                RTS
            SUB A, 0x30   ; get value of ASCII digit
            IFG [LINNUM], 6399 ; about to be >64000
                JMP SNERR
            MUL [LINNUM], 10
:ROMA995    ADD [LINNUM], A
:ROMA99F    JSR CHRGET
:ROMA9A2    JMP ROMA971 ; get next digit or return


:STMT_PRINTN
:ROMAA80    JSR ROMAA86
            JMP ROMABB5

:STMT_CMD
:ROMAA86    JSR ROMB79E ; get byte
            IFE Z, 1  ; i think it ends in CHRGOT
                JMP ROMAA90
            SET A, CBM_COLON
            JSR SYNCHR
:ROMAA90    SET PUSH, Z
            SET X, [CHANNL]
            JSR ROME118
            SET Z, POP 
            JMP STMT_PRINT

; stack safeguard
:PRINT_SP DAT 0

:SP_GUARD_FRMEVAL
        SET [PRINT_SP], SP
        JSR FRMEVAL
        IFE SP, [PRINT_SP]
            RTS
        ; report stack difference somehow
        SET [SCREENMEM+64], [PRINT_SP]
        SET [SCREENMEM+66], SP
        ; recover
        SET SP, [PRINT_SP]
        RTS

; Print string and get next thing.
:ROMAA9A    JSR ROMAB21
:ROMAA9D    JSR CHRGOT
:STMT_PRINT
:ROMAAA0    IFE Z, 1  ; print by itself, or non-semicolon-terminated
                JMP ROMAAD7 ; print CR
:ROMAAA2    IFE Z, 1
                RTS
:ROMAAA4    IFE A, BASIC_TAB_TOKEN   ; TAB(
                JMP ROMAAF8
            SET C, 0
            IFE A, BASIC_SPC_TOKEN   ; SPC(
                JMP ROMAAF8
            IFE A, CBM_COMMA
                JMP ROMAAE8
            IFE A, 0x3B ; SEMICOLON
                JMP ROMAB13
            JSR FRMEVAL
            IFB [VALTYP], 0x80 ; string
                JMP ROMAA9A    ; print string and restart
            JSR FOUT    ; convert float to string
            JSR STRLIT  ; prepare string in memory
            JSR ROMAB21 ; print string in [INDEX]
            JSR ROMAB3B ; print space ?
            JMP ROMAA9D  ; was a BNE, probably unconditional
            
; zero-terminate this string
:ROMAACA    SET [RAM0200+X], 0
            ; return location of input buffer in X
            SET X, RAM0200-1
            SET Z, 0
            IFN [CHANNL], 0
                RTS
            SET Z, 1

; RETURN at end of line on PRINT
:ROMAAD7 
            SET A, CBM_RETURN  
            JSR ROMAB47
            IFC [CHANNL], 0x80
                JMP ROMAAE5
            SET A, 0x0A  ; newline
            JSR ROMAB47
:ROMAAE5    XOR A, 0xFF 
            SET Z, 0
            SET C, 0  ; clear BREAK flag
            RTS

; routine for printing TAB( and SPC(
:STMT_TAB
:ROMAAE8    SET C, 1
            JSR PLOT
            SET A, Y
            SUB A, 10
            ; TODO: FINISH
:ROMAAF8    SET PUSH, C
            SET C, 1
            JSR PLOT
            SET [RAM09], Y
            JSR GETBYTC
            IFN A, 0x29 ; close paren
                JMP SNERR
            SET C, POP
            IFE C, 0
                JMP ROMAB0F
:ROMAB09    SET X, A
            SUB A, 9
            IFU A, 0  ; carry clear
                JMP ROMAB0E
            SET C, 0
            JMP ROMAB13
:ROMAB0E    SET X, A
:ROMAB0F    ADD X, 1
:ROMAB10    SUB X, 1
:ROMAB11    IFN X, 0
                JMP ROMAB19
            ; handle semicolon
:ROMAB13    JSR CHRGET
            JMP ROMAAA2
:ROMAB19    JSR ROMAB3B ; what does this return?
            IFN A, 0
                JMP ROMAB10

; print string form AY

:STROUT
:ROMAB1E    JSR STRLIT ; Scan and set up pointers
            
; print string from $22/$23 [INDEX]

:ROMAB21    JSR ROMB6A6  ; get address in X, length in A
            ; sanity check
            ;SET EX, 0x4444
            ;IFG A, 0x50   ; too long to be real
            ;    JMP CRASH  ;debug
            SET X, A         ; length to X
            SET Y, [INDEX]   ; address to Y
            ADD X, 1
:ROMAB28    SUB X, 1
            IFE X, 0
                RTS
            SET A, [Y]      ; character to A
            SET C, [CHRCOUNT]
            ; sanity check
            ;IFG A, 0xFF
            ;   JMP CRASH
            ;SET PUSH, X
            ;SET PUSH, Y
            JSR ROMAB47 ; print 1 character
            ;SET Y, POP; shouldn't destroy Y
            ;SET X, POP
            ADD Y, 1
            IFN A, CBM_RETURN  ; cr?
                JMP ROMAB28
:ROMAB35    JSR ROMAAE5  ; write RETURN
            JMP ROMAB28

            
; print character on CMD output file
; calling functions should check A instead of Z

:ROMAB3B    IFE [CHANNL], 0
                JMP ROMAB42
:ROMAB3F    SET A, 0x20   ; space
            IFE A, -1 ; skip next
:ROMAB42    SET A, CBM_RIGHT   
            IFE A, -1 ; skip next
:ROMAB45    SET A, 0x3F  ; question mark
:ROMAB47    JSR ROME10C
            ; AND #$FF
            SET Z, 0
            IFE A, 0
                SET Z, 1
:ROMAB4C    RTS

; Read errors

:DOAGIN
:ROMAB4D    SET A, [INPFLG]
            IFE A, INF_INPUT   ;0
                JMP ROMAB62
            IFE A, INF_READ
                JMP ROMAB57
            SET Y, -1
            JMP ROMAB5B
:ROMAB57    SET A, [DATLIN]
:ROMAB5B    SET [CURLIN], A ; Report error from other line.
            JMP SNERR
:ROMAB62    SET A, [CHANNL]
            IFE A, 0
                JMP ROMAB6B
            SET X, 0x18 ; ?FILE DATA ERROR
            JMP ERROR

; ?REDO FROM START          
:ROMAB6B    SET A, ROMAD0C
            JSR STROUT
            SET [RAM7A], [RAM3D]
            RTS

:STMT_INPUTN
:ROMABA5    JSR ROMB79E ; get byte
            SET A, CBM_COMMA
            JSR SYNCHR
            SET [CHANNL], X
            JSR ROME11E   ; CHKIN
            JSR ROMABCE   ; go to main INPUT subroutine
:ROMABB5    SET A, [CHANNL]
            JSR ROMFFCC
            SET [CHANNL], X
            RTS

:STMT_INPUT
:ROMABBF    SET C, 0
            IFN A, CBM_QUOTE 
                JMP ROMABCE
            ; handle INPUT "PROMPT";A$
:ROMABC3    IFG A, CBM_QUOTE
                SET C, 1
            JSR ROMAEBD ; start consuming string
            SET A, 0x3B  ; semicolon
            JSR SYNCHR  ; finish consuming string
            JSR ROMAB21
:ROMABCE    JSR ERRDIR ; handle illegal use in direct mode
:ROMABD1    SET A, CBM_COMMA
            SET [RAM01FF], A
:ROMABD6    JSR ROMABF9 ; get line into input buffer
            SET A, [CHANNL]
            IFE A, 0
                JMP ROMABEA
:ROMABDD    JSR ROMFFB7    ; get status
            AND A, 2
            IFE A, 0
                JMP ROMABEA
            JSR ROMABB5
            JMP STMT_DATA ; jump to end of statement
:ROMABEA    SET A, [RAM0200]
			IFN A, 0
                JMP ROMAC0D ; pass X as input buffer start
            SET A, [CHANNL]
            IFN A, 0
                JMP ROMABD6
            JSR ROMA906 ; get end of line in I
            JMP ROMA8FB ; ... = I, next statement.

; get line into input buffer
:ROMABF9    IFN [RAM13], 0
				JMP ROMAC03
			JSR ROMAB45 ; print question mark
			JSR ROMAB3B
:ROMAC03    JMP INLIN

:STMT_READ
:ROMAC06    SET X, [DATPTR]
            SET [INPFLG], INF_READ 
            IFE X, 0 ; skip next
:ROMAC0D    SET [INPFLG], 0 ; INPUT command entry
            SET [INPPTR], X ; start search position
:ROMAC15    JSR PTRGET  ; get variable name as Y
            SET [FORPNT], Y  ; we use FORPNT for assignments
            SET [OPPTR], [RAM7A]
            SET [RAM7A], [INPPTR] ; move cursor to reading location
            JSR CHRGOT
            IFE Z, 0
                JMP ROMAC51
            IFN [INPFLG], INF_GET ; BVC
                JMP ROMAC41
            JSR ROME124 ; get one character
            SET [RAM0200], A
            SET X, RAM01FF
            JMP ROMAC4D
:ROMAC41    IFE [INPFLG], INF_READ
				JMP ROMACB8
			SET A, [CHANNL]
            IFN A, 0
                JMP [ROMAC4A]
            JSR ROMAB45 ; print question mark
:ROMAC4A    JSR ROMABF9 ; get line into input buffer
:ROMAC4D    SET [RAM7A], X
:ROMAC51    JSR CHRGET
            IFC [VALTYP], 0x80 ; Numeric
                JMP ROMAC89
            IFN [INPFLG], INF_GET ; BVC
                JMP ROMAC65
:ROMAC5C    ADD X, 1
            SET [RAM7A], X
            SET [RAM07], A
            JMP ROMAC71
:ROMAC65    SET [RAM07], A
            SET C, 1 ; add 1 to address if quote matches
            IFE A, CBM_QUOTE
                JMP ROMAC72
            SET [RAM07], CBM_COLON
            SET A, CBM_COMMA
:ROMAC71    SET C, 0
:ROMAC72    SET [ENDCHR], A
            SET A, [RAM7A]
            ADD A, C
            JSR ROMB48D ; STRLIT without quotes?
            JSR ROMB7E2 ; move cursor to after string
            JSR ROMA9DA ; assign to a string variable
            JMP ROMAC91 ; handle any extra
:ROMAC89    JSR FIN ; convert string to float
            SET A, [INTFLG]
            JSR ROMA9C2 ; assign to float or integer.
:ROMAC91    JSR CHRGOT
            IFE Z, 1        ; end of input
                JMP ROMAC9D
            IFE A, CBM_COMMA ; end of variable
                JMP ROMAC9D
            JMP DOAGIN ; process input errors
:ROMAC9D    SET [INPPTR], [RAM7A]
            SET [RAM7A], [OPPTR] ; return cursor to program listing
            JSR CHRGOT
            IFE Z, 1
                JMP ROMACDF  ; no more variables in statement
            JSR CHKCOM       ; OR, comma
            JMP ROMAC15      ; followed by another variable
; find next DATA statement
:ROMACB8    JSR ROMA906 ; get next statement in I
; todo: finish this I pointer's trek through the program
            ADD I, 1 
            IFN A, 0
                JMP ROMACD1
:ROMACBF    SET X, 0x0D ; error number
            ADD I, 1
            IFE [I], 0 ; no next line?
                JMP ERROR ; throw ?OUT OF DATA
        	ADD I, 1
        	SET [DATLIN], [I]
:ROMACD1    SET [RAM7A], I
            JSR CHRGOT
            SET X, A
            IFN X, BASIC_DATA_TOKEN ; DATA code
                JMP ROMACB8
            JMP ROMAC51
:ROMACDF    SET A, [INPPTR]
            IFE [INPFLG], INF_READ ; bpl
            	JMP ROMA827 ; set next line's data stmt
            IFE [A], 0
                RTS
            IFN [CHANNL], 0
                RTS
:ROMACF4    SET A, EXIGNT
            JMP STROUT

:EXIGNT
:ROMACFC
    DAT "?EXTRA IGNORED", CBM_RETURN, 0
:REDOMSG
:ROMAD0C
    DAT "?REDO FROM START", CBM_RETURN, 0

; NEXT statement - see STMT_FOR
:STMT_NEXT
:ROMAD1E    IFE Z, 0
                JMP ROMAD24
			SET Y, 0     ; don't know which variable to advance
            JMP ROMAD27
:ROMAD24    JSR PTRGET   ; get variable to advance in Y
:ROMAD27    SET [FORPNT], Y
            JSR FNDFOR
            ; [FORPNT] contains the variable we're really looping
            IFE Z, 1    ; found the variable
                JMP ROMAD35
:ROMAD30    SET X, 0x0A ; ?NEXT WITHOUT FOR
            JMP ERROR
:ROMAD35    SET SP, X  ; synchronize stack with that FOR
			; this discards any inner loops we've skipped
:ROMAD42	SET A, SP
			ADD A, 2   ; pointer to STEP value
			JSR MOVFM  ; set FAC1
			SET [FACSGN], PICK 5
:ROMAD4B	SET A, [FORPNT] ; pointer to loop variable
:ROMAD4F	JSR FADD        ; add to STEP value
			JSR ROMBBD0     ; set loop variable to result
			SET A, SP
			ADD A, 6   ; pointer to TO value
			JSR FCOMP ; compare TO value (I) with loop variable
			; break out if comparison matches sign of STEP
			IFE A, PICK 5
				JMP ROMAD78
:ROMAD61	; last time through loop
			SET [CURLIN], PICK 9
			SET [RAM7A], PICK 10
:ROMAD75	JMP NEWSTT
			; end of loop
:ROMAD78	ADD SP, 11    ; pop FOR block from stack
			JSR CHRGOT
:ROMAD80	IFN A, CBM_COMMA
				JMP NEWSTT
			JSR CHRGET   ; it's NEXT X,Y -- do NEXT Y also
			JSR ROMAD24  ; must JSR so that the POP works.
 
; get formula, enforce that it is a number.
:FRMNUM
:ROMAD8A    JSR FRMEVAL
; check value to be numeric
:ROMAD8D    IFB [VALTYP], 0x8000
                JMP ROMAD99
            RTS
; check value to be string
:ROMAD8F    IFC [VALTYP], 0x8000
                JMP ROMAD99
            RTS
; this one will need a lot of testing
; check value according to C flag
:ROMAD90    IFB [VALTYP], 0x8000
                JMP ROMAD97
            IFE C, 1
                JMP ROMAD99
            RTS
:ROMAD97    IFE C, 1
                RTS
:ROMAD99    SET X, 0x16  ; ?TYPE MISMATCH ERROR
            JMP ERROR

                    
; evaluate formula, store result in FAC
; sets [VALTYP] to 0 if result is a floating point number
;                 -1 if result is a string pointer
:FRMEVAL
:ROMAD9E    SUB [RAM7A], 1
            SET X, 0
            IFE X, 1 ; push X instead of A
; if we enter at ROMADA9, we push on the stack:
;   A from [OPMASK]
;   X from somewhere in TBL_OP's left column.
:ROMADA9    SET PUSH, A
:ROMADAA    SET PUSH, X 
            SET A, 1
            JSR GETSTK
            JSR EVAL ; get a single floating point number
            SET [OPMASK], 0
            ; 
:ROMADB8    JSR CHRGOT
:ROMADBB    XOR B, 0xABAB
            XOR B, 0xABAB
; check for comparison operators.  This is a loop so that
; the combinations <>, <=, and => work.
:ROMADBC    SUB A, 0xB1 ; code for greater-than
            IFU A, 0
                JMP ROMADD7
            IFA A, 2         ;CMP #3
                JMP ROMADD7  ;BCS $ADD7
            SHL A, 1         ;CMP #$01
            IFL A, 1         ;ROL
                BOR A, 0x01  ;EOR #$01
            XOR A, [OPMASK]
            IFL A, [OPMASK]
                JMP SNERR
            SET [OPMASK], A
            JSR CHRGET
            JMP ROMADBB  ; check for more comparison operators
            ; done detecting comparison operators
:ROMADD7    IFN [OPMASK], 0  ; comparison operator exists
                JMP ROMAE07
            IFC A, 0xf000 ; result from SUB above was positive
                JMP ROMAE58
            ADD A, 7  ; - 0xB1 + 7 = -0xAA
            IFU A, 0   ; still less than 0
                JMP ROMAE58
            IFE [VALTYP], 0
                ADD A, 1
            IFC A, 0xFF  ; zero in 8-bit
                JMP CAT
:ROMADE8    IFC A, 0x100 ; Carry bit clear in original
                SUB A, 1
            MUL A, 2  ; I think the 6502 version multiplied by 3
            ; Y now contains an index into the operator table.
            SET Y, A
            ; if we're on the right side of an operator,
            ; this POPs the precedence of that operator,
            ; so we know whether to keep going.
:ROMADF0    SET A, POP
            ; TODO: re-examine this interpretation
            SET X, [TBL_OP+Y]
            SUB X, 1 ; testing for greater-or-equal
            IFG A, X
                JMP ROMAE5D  ; pop stack into ARG and return
            JSR ROMAD8D ; check that term is numeric
:ROMADF9    SET PUSH, A
            ; the value of Y should be set to
            ; a TBL_OP offset at this entry point
:ROMADFA    JSR ROMAE20
:ROMADFD    SET A, POP
            IFC [OPPTR], 0x8000  ; positive in 8-bit
                JMP ROMAE19
            SET X, A
            IFE X, 0
                JMP ROMAE5B
            JMP ROMAE66         

; handle comparison operators
; the first instruction here was LSR $0D, which I think was there
; to both set VALTYP to "numeric" for all future BMI tests, while
; getting its carry bit from the low bit.  I'll have to investigate.
:ROMAE07    SHR [VALTYP], 1   
            SET C, EX        
            SET A, [OPMASK]
            SHL A, 1
            BOR A, C
:ROMAE08    SUB [RAM7A], 1
            SET Y, 18   ; was 27 bytes, now 18 words 
            SET [OPMASK], A  ; ?
            JMP ROMADF0
:ROMAE19    IFL A, [TBL_OP+Y]
                JMP ROMADF9
            JMP ROMAE66
            
; recursive entry for evaluation of expression
:ROMAE20    
            SET PUSH, [TBL_OP+1+Y]
            JSR ROMAE33  ; push FAC onto stack
            SET A, [OPMASK]
            ; X is set to the order of precedence of
            ; this operator.
            ; A is set to [OPMASK]
            JMP ROMADA9  ; call FRMEVAL on the right side.

; push FAC onto stack (4 WORDS)
; save rounded value of left operand
; X is set to the first column of the operator table
:ROMAE33    SET X, [TBL_OP+Y]
			SET A, [FACSGN]
			; Other entry points are used by FOR
			; statement to push floats.
:ROMAE38	SET I, POP
            SET PUSH, A
:ROMAE43    JSR ROUND
            SET PUSH, [FACHO+1]
            SET PUSH, [FACHO]
            SET A, [FACEXP]
            SET PUSH, A
            JMP I    ; instead of RTS

; Pop ARG from stack (4 WORDS)
:ROMAE58    SET Y, -1
            SET A, POP
:ROMAE5B    IFE A, 0 ; oh wait, there's no operator
                JMP ROMAE80
            ; A contains a precedence level
:ROMAE5D    IFE A, 0x64   ; comparison operator
                JMP ROMAE64
            JSR ROMAD8D ; check that term is numeric
:ROMAE64    SET [OPPTR], Y
:ROMAE66    SET A, POP
            SHR A, 1
            SET [RAM12], A
            SET [ARGEXP], POP 
            SET [ARGHO], POP 
            SET [ARGHO+1], POP 
            SET A, POP
            SET [ARGSGN], A
            XOR A, [FACSGN]
            ASR A, 15
            SET [ARISGN], A
:ROMAE80    SET A, [FACEXP]
:ROMAE82    RTS

; get arithmetic element routine            
; convert a single numeric term, such as
; a number or variable name, from 
; ASCII text to a floating point number
:EVAL
:ROMAE83    JMP [RAM030A]
:DEF_EVAL
:ROMAE86    SET [VALTYP], 0   ; numeric
:ROMAE8A    JSR CHRGET
            IFE C, 0 ; is a digit
                JMP FIN  ; read number into float
:ROMAE92    JSR ISALPHA
            IFE C, 1 ; is alpha
                JMP ROMAF28  ; must be a variable...
:ROMAE9A    IFN A, 0xFF ; PI character
                JMP ROMAEAD
            SET A, PIVAL
            JSR MOVFM
            JMP CHRGET
:PIVAL      DAT 0x82, 0x490F, 0xDAA1  ; float value of PI
			; not a digit, variable, or pi:
:ROMAEAD    SET C, 1 ; so FIN knows dot isn't a digit
            IFE A, 0x2E ; Decimal point
                JMP FIN ; read a number
            IFE A, BASIC_MINUS_TOKEN
                JMP ROMAF0D
            IFE A, BASIC_PLUS_TOKEN
                JMP ROMAE8A
            IFN A, CBM_QUOTE ; quote mark
                JMP ROMAECC
        	SET C, 0
            IFG A, CBM_QUOTE-1 ; carry over from 6502 CMP above
                SET C, 1 
; remember to set carry bit before jumping here.
; this entry point consumes a string in quotes.
:ROMAEBD    SET A, [RAM7A]
			ADD A, C
            JSR STRLIT
            JMP ROMB7E2  ; move RAM7A cursor to AFTER string
             ; and return.
			;not a digit, variable, pi, string, or */-
:ROMAECC    IFN A, BASIC_NOT_TOKEN
                JMP ROMAEE3
            SET Y, 12 ; vector into TBL_OP
                JMP ROMAF0F

; NOT operator
:NOTOP
:ROMAED4    JSR AYINT 
            SET A, [FACHO+1]
            XOR A, -1
            JMP GIVAYF

; get operand

:ROMAEE3    IFE A, BASIC_FN_TOKEN ; FN
                JMP FNDOER
:ROMAEEA    IFG A, 0xB3 ; Token for a function or operator 
                JMP ISFUN
:PARCHK
:ROMAEF1    JSR CHKOPN
            JSR FRMEVAL
            ; Fall through to CHKCLS

; CHECK for the appropriate punctuation,
; and skip it.
:CHKCLS
:ROMAEF7    SET A, 0x29  ; close paren
            JMP SYNCHR
:CHKOPN
:ROMAEFA    SET A, 0x28  ; open paren
            JMP SYNCHR
:CHKCOM
:ROMAEFD    SET A, CBM_COMMA
; Next non-whitespace character should be A,
; otherwise it's a syntax error.
:SYNCHR
:ROMAEFF    SET Y, [RAM7A]
            IFE [Y], A
                JMP CHRGET
:SNERR ; ?SYNTAX  ERROR
:ROMAF08    IFE DEBUG_SNERR, 1
				JSR PRINT_EXPECTED
			SET X, 0x0B ; 
            JMP ERROR

:SN_EXPECTED	DAT 0
:SN_GOT  		DAT 0
; new feature: prints the character it was expecting
:PRINT_EXPECTED
		SET [SN_EXPECTED], A
		SET [SN_GOT], [Y]
		SET A, EXPECTED_MSG
		JSR STROUT
		SET A, [SN_EXPECTED]
		JSR CHROUT
		SET A, GOT_MSG
		JSR STROUT
		SET A, [SN_GOT]
		IFE A, 0
			JMP SN_GOT_NULL
		JMP CHROUT
:SN_GOT_NULL
		SET A, NULL_MSG
		JMP STROUT
				
:EXPECTED_MSG
	DAT 13,"EXPECTED ", 0
:GOT_MSG
	DAT ", GOT ", 0
:NULL_MSG
	DAT "NULL", 0

; RECURSIVE get value

:ROMAF0D    SET Y, 14 ; vector into TBL_OP
:ROMAF0F    SET A, POP ; WHY 2?
            JMP ROMADFA

; Check variable pointer range
; I think it uses a hard-coded top of RAM?
; so I guess I'll do the same.
:ROMAF14    SET A, [RAM64]
            SUB A, BASICMEMEND
            IFE EX, -1  ; underflow
                JMP ROMAF27
            SET A, ROME3A2 ; what is this?
            SUB A, [RAM64]
:ROMAF27    SET C, EX ; set C registor to what
            ADD C, 1 ; 6502 carry bit would have been
            RTS
            
; Get value of variable for EVAL
:ROMAF28    JSR PTRGET  ; get pointer in Y
:ISVAR
:ROMAF2B    SET [RAM64], Y
			SET X, [VARNAM]
			SET Y, [VARNAM+1]
            IFE [VALTYP], 0
                JMP ROMAF5D
            SET [FACOV], 0
            JSR ROMAF14 ; check varptr range?
            ; If not found
:ROMAF3E    IFE C, 0
                RTS
:ROMAF40    ; TODO: Check for TI$
            RTS
            
:ROMAF5C    RTS

:ROMAF5D    IFC [INTFLG], 0x80 
                JMP ROMAF6E
            SET A, [RAM64]  ; is integer
            JMP GIVAYF

:ROMAF6E    JSR ROMAF14  ; check variable pointer range?
            IFE C, 0 ; Not found?
                JMP ROMAFA0
            ; TODO: check for TI and ST
            JMP ROMAFA0
            ; First character of numeric variable
            ; wasn't T, but maybe it's S?
; continue of get value of variable
:ROMAF92    IFN X, 0x53  ; S
                JMP ROMAFA0
            IFN Y, 0x54  ; T
                JMP ROMAFA0
            JSR ROMFFB7
            JMP ROMBC3C
:ROMAFA0    SET A, [RAM64]
            JMP MOVFM

:ISFUN   ; is a basic function?
:ROMAFA7    SET PUSH, A ; originally *2
            SET X, A
            JSR CHRGET
            IFL X, BASIC_LEFT_TOKEN ; LEFT$ token
                JMP ROMAFD1
            ; handle two-argument functions (LEFT$ etc)
            JSR CHKOPN
            JSR FRMEVAL
            JSR CHKCOM
            JSR ROMAD8F ; check value is string
            SET X, POP
            SET PUSH, [RAM64]
            SET PUSH, X
            JSR ROMB79E  ; get small integer
            SET Y, POP
            SET A, X
            SET PUSH, A
            JMP ROMAFD6
            ; handle single-argument functions
:ROMAFD1    JSR PARCHK ; evaluate between parens
            SET Y, POP
			SET A, Y ; DEBUG
			SET B, FUNCTION_VECTOR ; DEBUG
			SET C, FUNCTION_ROUTINES
:ROMAFD6    ADD Y, FUNCTION_VECTOR
			JSR [Y]
			JMP ROMAD8D ; check return is numeric

; OR/AND operators

:ROMAFE6	SET Y, -1
			IFN Y, -1 ; skip next
:ROMAFE9	SET Y, 0
			SET [RAM0B], Y
			JSR AYINT    ; float to integer
			SET A, [RAM64]
			XOR A, [RAM0B]
			SET [RAM07], A
			JSR MOVFA
			JSR AYINT
			SET A, [RAM64]
			XOR [RAM0B]
			AND [RAM07]
			XOR [RAM0B]
			JMP GIVAYF
				

; get time in float accu
:ROMAF84    JSR ROMFFDE
            ; STX $64
            ; STY $63
            ; STA $65
            ; LDY #0
            ; STA $62
            RTS

; comparison operators

:ROMB016	JSR ROMAD90
			IFE C, 1
				JMP ROMB02E
			SET A, [ARGSGN]
			BOR A, 0x7FFF
			AND A, [ARGHO]
			SET [ARGHO], A
			SET A, ARGEXP
			JSR FCOMP
			SET X, A
			JMP ROMB061
:ROMB02E	SET [VALTYP], 0 ; numeric
			SUB [RAM4D], 1
			JSR ROMB6A6  ; get string length and address
			SET [RAM61], A
			SET [RAM62], X
			DAT 0x5C00   ; will do string compares later
:ROMB061	IFB X, 0x8000
				JMP ROMB072
			SET C, 0
			JMP ROMB072
:ROMB066	DAT 0x5400   ; should go to bed
:ROMB072	DAT 0x5800

;get name and pointer to a variable.
; At the end, the cursor should be at the last character of 
; the variable name.
; Returns pointer in Y (originally AY)
:PTRGET
:ROMB08B    SET X, 0
            JSR CHRGOT
            SET [DIMFLG], X
:ROMB092    SET [VARNAM], A ; store first letter of variable
            ; throw SYNTAX if first character is not a letter.
            JSR CHRGOT
            JSR ISALPHA
            IFE C, 0
                JMP SNERR
:ROMB09F    SET [VALTYP], 0  ; numeric
            SET [INTFLG], 0
            JSR CHRGET
            IFE C, 0 ; is a digit
                JMP ROMB0AF
            JSR ISALPHA
            IFE C, 0 ; not alpha
                JMP ROMB0BA
:ROMB0AF    SET X, A
            ; only first two characters count
            ; discard the rest of the variable name
:ROMB0B0    JSR CHRGET
            IFE C, 0 ; ...
                JMP ROMB0B0
            JSR ISALPHA
            IFE C, 1 ; is alpha
                JMP ROMB0B0
:ROMB0BA    ; consumed entire name of variable
            ; look for sigil at the end
            IFN A, 0x24 ; $ for string
                JMP ROMB0C4
            SET [VALTYP], -1  ; string
            JMP ROMB0D4
:ROMB0C4    IFN A, 0x25 ; % for integer
                JMP ROMB0DB
            SET A, [RAM10]
            IFN A, 0
                JMP ROMAF08
            SET [INTFLG], 0x80
            BOR [VARNAM], 0x80
:ROMB0D4    BOR X, 0x80
            JSR CHRGET
:ROMB0DB    SET [VARNAM+1], X
            BOR A, [RAM10]
            SUB A, 0x28 ; left paren
            IFE A, 0
                JMP ROMB1D1
:ROMB0E7    SET [RAM10], 0
            SET Y, [VARTAB]  ; pointer
            SET A, [VARNAM]    ; first char of cariable
            SET B, [VARNAM+1]  ; 2nd char of variable
:ROMB0F3    SET [RAM5F], Y
            IFE Y, [ARYTAB] ; end of table?
                JMP NOTFNS         ; Create a variable
            IFN A, [Y]
                JMP ROMB109
            IFE B, [Y+1]
                JMP ROMB185  ; return pointer
:ROMB109    ADD Y, 5 ; move pointer to next entry
            JMP ROMB0F3
            
; set C=1 if character in A is alphabetic
; might be slightly faster if we converted this
; to use the DCPU-16 EX register.
:ISALPHA
:ROMB113    SET C, 1
            IFL A, 0x41 ; A
                SET C, 0
            IFG A, 0x5B ; Z
                SET C, 0
            RTS

:NOTFNS ; Create a new BASIC variable
; VARIABLE POINTERS ARE 5 WORDS INSTEAD OF 7 BYTES
; todo: figure out what was pushed on the stack
:ROMB11D    SET A, PEEK
            IFN A, 0x2A ; Array?
                JMP ROMB128
            ; i am stumped as of now
:ROMB123    SET Y, ROMBF13 ; ?
            RTS
:ROMB128    SET A, [VARNAM]
            SET Y, [VARNAM+1]
            IFN A, 0x54 ; T
                JMP ROMB13B
            IFE Y, 0xC9 ; I$
                JMP ROMB123
            IFE Y, 0x49 ; I
                JMP ROMAF08 ; can't set TI
:ROMB13B    IFN A, 0x53 ; S
                JMP ROMB143
            IFE A, 0x54 ; T
                JMP ROMAF08
:ROMB143    SET [RAM5F], [ARYTAB] ; start of source
            SET A, [STREND] ; end of all variables
            SET [RAM5A], A  ; end of source
            ADD A, 5        ; room for one variable
            SET [RAM58], A ; end of destination
            JSR BLTU
            ; move array table up
            SET [ARYTAB], [RAM58]
            SET Y, [RAM5F]
            ; bytes 1&2: name
            SET [Y], [VARNAM]
            SET [Y+1], [VARNAM+1]
            ; bytes 3-5 depend on type
            SET [Y+2], 0
            SET [Y+3], 0
            SET [Y+4], 0
; Variable found 
:FINPTR
:ROMB185    ADD Y, 2 ; skip past name, to contents
            SET [VARPNT], Y
            RTS         
; absolutely nothing goes wrong assigning the first variable
; the second variable screws up everything
            

; Compute pointer to array body

:ROMB194    SET A, [COUNT]
            ADD A, 5    ; why 5?
            ADD A, [RAM5F]
            SET [RAM58], A  ; End of destination
            RTS

:N32768
:ROMB1A5    DAT 0x90, 0x8000, 0x0000

; routine to convert float to fixed point
:ROMB1AA    JSR AYINT
            SET A, [FACHO+1]
            RTS

:INTIDX ; Convert floating point subscript
        ; to a positive integer
:ROMB1B2    JSR CHRGET
:ROMB1B5    JSR FRMEVAL
:ROMB1B8    JSR ROMAD8D  ; check that term is numeric
            IFG [FACSGN], 0x7F  ; check that it is positive
                JMP FCERR
; convert float to integer
:AYINT
:ROMB1BF    SET A, [FACEXP]
            IFL A, 0x90
                JMP QINT
            SET A, N32768 ; -32768
            JSR FCOMP
:ROMB1CC    IFU A, 0    ; less than -32768
                JMP FCERR ; Illegal Quantity
            JMP QINT

;Find Array Element or Create New Array in RAM
;
;This routine searches for an array.  If it is found, the subscript
;value is checked to see if it is valid, and pointers to the array and
;element of the array are set.  If it is not found, the array is
;created, and the pointers set.
:ISARY
:ROMB1D1    SET EX,0xB1D1
            JMP CRASH

:BSERR
:ROMB245    SET X, 0x12 ; ?BAD SUBSCRIPT
            JMP ERROR
:FCERR
:ROMB248    SET X, 0x0E ; ?ILLEGAL QUANTITY
            JMP ERROR
:ROMB24D    SET X, 0x13 ; ?REDIM'D ARRAY
            IFN [RAM0C], 0
                JMP ERROR
            JSR ROMB194

:ROMB256    SET A, [RAM0B]
        SET Y, 4
        ADD Y, [RAM5F]
        IFN A, [Y]
            JMP BSERR
        JMP ROMB2EA

; compute reference to array element
:ROMB2EA    SET EX, 0xB2EA
            JMP CRASH

; fre(0)
:ROMB37D	IFN [VALTYP], 0
				JSR ROMB6A6  
			JSR ROMB526
			SET A, [RAM33]
			SUB A, [RAM31]
			; fall through to GIVAYF
			; TODO: make it unsigned.
			; the answer may be >32768.

:GIVAYF ;Convert 16-Bit Signed Integer to Floating Point
:ROMB391    SET [VALTYP], 0   ; numeric
            SET [FACHO], A
            SET X, 0x90
            JMP ROMBC44 ; normalize
            

; throw ?ILLEGAL DIRECT if not in direct mode
:ERRDIR
:ROMB3A6    IFL [CURLIN], 0xFF00
                RTS
            SET X, 0x15 ; ILLEGAL DIRECT
            IFN X, 0x15 ; skip next
:ROMB3AE    SET X, 0x1B ; UNDEF'D FUNCTION
                JMP ERROR

            
; get function name
:ROMB3E1    SET A, BASIC_FN_TOKEN ;FN
            JSR SYNCHR
            XOR A, 0x80
            SET [RAM10], A
            JSR ROMB092 ; within PTRGET.
            SET [DEFPNT], A
            JMP ROMAD8D ; check that term is numeric
            
; expand FN call
:FNDOER
:ROMB3F4    ;JSR ROMB3E1
            SET EX, 0xB3F4
            JMP CRASH
:STRD
:ROMB465    JSR ROMAD8D ; arg must be numeric
            SET Y, FLOATSTR-1
            JSR ROMBDDF   ; FOUT+1
            SET A, POP  ; originally 2x PLA
:ROMB46F    SET A, FLOATSTR-1
            JMP STRLIT
            
            ; create pointers to the string
:ROMB475    SET [DSCPNT], [RAM64]

:ROMB47D    JSR GETSPA    ; Allocate Memory in A
            SET [RAM62], X  ; string address 
            SET [RAM61], A  ; string length
            RTS


; get description of string into a location
; on the temporary string stack.
; Pass: A as location of string.
;       [CHARAC] as ...
;       [ENDCHR] as the end character, 0x22 or 0x00.
; Returns: length, then address, stored to the
;          location pointed to by TEMPPT.
;          2 added to [TEMPPT]
; Should set [INDEX]
; stores length in [RAM61]
; stores address in [RAM62]
:STRLIT
:ROMB487    SET X, CBM_QUOTE ; quote
            SET [CHARAC], X
            SET [ENDCHR], X
; enter here if CHARAC and ENDCHR aren't quotes
:ROMB48D    SET [RAM6F], A   ; String pointer
            SET [RAM62], A   ; String beginning pointer
            ; LOOP to...???
            SET I, [RAM6F]
            SUB I, 1

:ROMB497    ADD I, 1
            ;IFG [ARYTAB], [VARTAB]
            ;   JMP STRDEBUG
:ROMB498    SET A, [I]         ; get character
            IFE A, 0
                JMP ROMB4A8
            IFE A, [CHARAC]    ; 
                JMP ROMB4A4
            IFN A, [ENDCHR]    ;
                JMP ROMB497
:ROMB4A4    
:ROMB4A8    
:ROMB4A9    SET Y, I         ; subtract original pointer
            SUB Y, [RAM6F]   ; to obtain the length
			IFE A, CBM_QUOTE 
            	ADD I, 1     ; put end past trailing quote
            SET [RAM61], Y  ; Length in [RAM61]
            SET [RAM71], I  ;originally had to add Y to RAM6F
            ; oh wait this is a test on MSB of RAM6F
            SET A, [RAM6F]
            ; i think this bit here is set to treat
            ; stuff in the 200-2FF range different from
            ; stuff in the ROM range
:ROMB4B7	IFE [RAM6F], 0   ; test for whatever happens below B4D5.
                JMP ROMB4BF  ; it makes the memory copy unconditional
            IFG A, RAM0200+BASIC_BUFFER_LENGTH ; not immediate mode
                JMP ROMB4CA  ; skip memory copy 
            IFU A, RAM0200
                JMP ROMB4CA  ; skip memory copy
            ; if it's in the temporary string area,
            ; it needs to be moved into memory
:ROMB4BF    ; Y should have a string length now
			; and RAM6F should be the start of source memory
            SET A, Y        ; send A as length
            JSR ROMB475     ; send destination in [FRESPC]
            SET X, [RAM6F]  ; send source as X
            JSR ROMB688     ; move string to [FRESPC]
; save descriptor from $61-$63 on stack
:ROMB4CA    IFU [TEMPPT], TEMPSTEND 
                JMP ROMB4D5 
            ; if no room on stack
:ROMB4D0    SET X, 0x19 ; ?FORMULA TOO COMPLEX
            JMP ERROR
            SET EX, 3
            ;JMP ERROR
:ROMB4D5    SET I, [TEMPPT] ; current pointer location
            SET [I], [RAM61]    ; Length
            SET [I+1], [RAM62]  ; Pointer
            SET [RAM64], I    ; Pointer to pointer 
            SET [FACOV], 0 ; literal translation
            SET [RAM6F], 0 ; probably meant to do this
            SET [VALTYP], -1 ; string
            SET [LASTPT], I
            ADD I, 2
            SET [TEMPPT], I
:ROMB4F3    RTS
;
:STRDEBUG
            ;SET A, [TEMPPT]
            ;SET B, TEMPST
            ;SET C, TEMPSTEND
            ;SET X, [FACEXP]
            ;SET Y, [FACHO]
            SET B, [RAM7A]
            DAT 0x3400
            RTS
;
; allocate number of bytes in A
; The amount of space needed for a string is 
; passed to this routine, and the routine checks 
; if there is that amount of space available in free
; memory. If not, it does a garbage collection and 
; tries again.
; Returns original length requested in A
; Returns address in X (originally XY)
; array ptr
.DEFINE GARB_LG 7
; single string ptr
.DEFINE GARB_SM 3
; due to the 6502's zero-page advantage, these
; bytes were all cached in the original version.
; here, we just allocate more memory
:GAR57 DAT 0
:GAR58 DAT 0
:GAR59 DAT 0
:GAR5A DAT 0
:GAR5B DAT 0
:GAR5C DAT 0
:GAR5D DAT 0
:GAR5E DAT 0
:GAR5F DAT 0
; get space at end of memory
; parameter: number of words required in A
; returns pointer in X
:GETSPA
:ROMB4F4    ;SET EX, [GARBFL]
			SHR [GARBFL], 1
            ;SET C, EX  ;???
:ROMB4F6    ;WARNING: potential for off-by-one error here
            SET X, [FREETOP] ; pointer to end of free RAM
            SUB X, A         ; subtract length of string
            IFL X, [STREND]  ; compare with start of free RAM
                JMP ROMB516
            SET [FREETOP], X ; allocate free RAM
            SET [FRESPC], X ; temporary space for strings
            ; A still contains the length 
            RTS
            
:ROMB516    DAT 0x6C00   ; don't know how to GC yet
			SET X, 0x10
            SET B, [GARBFL]
            IFG B, 0x7f
                JSR GARBAG
            SET [GARBFL], 0x80
            SET A, POP
            IFN A, 0 ; why would it ever be 0?
                JMP ROMB4F6
:GARBAG
:ROMB526    SET A, [MEMSIZ]
:ROMB52A    SET [FREETOP], A
            SET [DEFPNT], 0
            SET [GAR5F], [STREND]
            SET 0x1234, 0x5678
:ROMB53C    SET A, TEMPST   ; ???
:ROMB540    SET [INDEX], A  ; 
:ROMB544    IFE A, [TEMPPT]
                JMP ROMB54D
            JSR ROMB5C7
            IFE Z, 1
                JMP ROMB544
:ROMB54D    SET [FOUR6], GARB_LG  ; number of bytes
            SET A, [VARTAB]
            SET [INDEX], A
:ROMB559    IFE [ARYTAB], A
                JMP ROMB566
:ROMB561    JSR ROMB5BD
            IFE Z, 1
                JMP ROMB559 ; compare AX again
:ROMB566    SET [GAR58], A
            SET [FOUR6], GARB_SM ; number of bytes
:ROMB56E    SET A, [GAR58]
:ROMB572    IFE [STREND], A
                JMP ROMB57D
            JMP ROMB606
:ROMB57D    SET [INDEX], A
:ROMB581    SET I, [INDEX]
:ROMB583    SET X, [I]
:ROMB586    ADD I, 1
            SET B, [I]  ; originally pushed 
:ROMB58A    ADD I, 1    ; one fewer than in 8-bit version
:ROMB58B    ADD [GAR58], [I] ;
:ROMB591    ; high byte skipped
            IFL B, 0x80      ; PLP
                JMP ROMB56E  ; BPL ROMB56E
            IFG X, 0x7F      ; TXA
                JMP ROMB56E
:ROMB59E    ADD I, 1
            SET A, [I]
            SET Y, 0
:ROMB5A3    SHL A, 1  ; really need to multiply by 2?
:ROMB5A4    ADD A, 5
:ROMB5A6    ADD [INDEX], A
            SET A, [INDEX]
:ROMB5B0    IFE A, [GAR58]
                JMP ROMB572
:ROMB5B8    JSR ROMB5C7
            IFE Z, 1    ; Zero bit set
                JMP ROMB5B0
                
; CHECK STRING AREA
; I.E. Check for most eligible string to collect
:ROMB5BD    SET Z, 0
            SET I, [INDEX]
            IFG [I], 0x7F ; BMI
                JMP ROMB5F6
            ADD I, 1
            IFL [I], 0x80 ; BPL
                JMP ROMB5F6
            ADD I, 1
            
; This takes A as a parameter?
; This needs to return A and Z
:ROMB5C7    SET Z, 0
            IFE [I], 0
                JMP ROMB5F6
            ADD I, 1
            SET A, [I]   ; one fewer byte than 8-bit ver
            IFL A, [FREETOP]
                JMP ROMB5DC
            JMP ROMB5F6
:ROMB5DC    IFL A, [RAM5F]
                JMP ROMB5F6
            IFN A, [RAM5F]
                JMP ROMB5E6
            JMP ROMB5F6
:ROMB5E6    SET [RAM5F], A
            SET A, [INDEX]
            SET [DEFPNT], A
            SET [RAM55], [FOUR6]
:ROMB5F6    SET A, [INDEX] ; we do this on A because
            ADD A, [FOUR6] ; it's going to be the
            SET [INDEX], A ; return value.
            SET Y, 0
            SET Z, 1
            RTS

            ; SOME MISSING
; CONTINUATION OF GARBAGE CLEAN UP

:ROMB601    SET A, [INDEX]  ; Why just the high bit?
            SET Y, 0
            SET Z, 1
            RTS
            ; COLLECT A STRING
:ROMB606    IFE [DEFPNT], 0
                JMP ROMB601
            SET Y, [RAM55]
            AND Y, 4     ; ???
            SHR Y, 1     ; ???
            SET [RAM55], Y
            SET I, [DEFPNT] ; ($4E),Y
            ADD I, Y
            SET A, [I]
            ADD A, [RAM5F]  ; 16-bit
            SET [RAM5A], A
            SET A, [FREETOP]
            SET [RAM58], A ; End of destination
:ROMB628    JSR ROMA3BF ; copy memory
:ROMB62B    SET Y, [RAM55]
            ADD Y, 1
            SET I, [DEFPNT]
            ADD I, Y
            SET [I], [RAM58] ; Points to end of destination
            ; A should contain something
            ; suitable to be stored in [FREETOP] ($33)
            JMP ROMB52A

; JOINING STRINGS
:CAT
:ROMB63D    ; DEBUG STACK POINTER
            SET PUSH, [RAM64]
            JSR EVAL
            JSR ROMAD8F ; check that value is string
            SET [RAM6F], POP
            SET Y, [RAM6F]
            SET A, [Y]  ; Get length of first string
            SET Y, [RAM64]
            ADD A, [Y]  ; Get length of second string
            IFL A, 0x100 ; TODO: make customizable
                JMP ROMB65D
            SET X, 0x17 ; ?STRING TOO LONG
            JMP ERROR
:ROMB65D    JSR ROMB475 ; allocate memory, store len/ptr in A/X
            JSR MOVINS  ; move string in [RAM6F] to temporary string
            SET A, [DSCPNT]
            JSR ROMB6AA ; set [INDEX] to [DSCPNT] then de-allocate 
            JSR ROMB68C ; copy that too.
            SET A, [RAM6F]
            JSR ROMB6AA ; set [INDEX] to [RAM6F] then de-allocate
            JSR ROMB4CA ; save descriptor on stack
            JMP ROMADB8

; move string
; move string pointed to by RAM6F, into that pointed to by INDEX.
:MOVINS
:ROMB67A
            SET Y, [RAM6F]
            SET A, [Y]
            SET X, [Y+1]

; move string with length A, pointer in XY
; starting from the end
; if you jump to ROMB68C, [INDEX] should already be set

:ROMB688    SET [INDEX], X
:ROMB68C    SET I, [INDEX]  ; source
:ROMB68D    IFE A, 0   ; zero length
                JMP ROMB699 ; do nothing
            ADD I, A        ; source
            SET J, [FRESPC] ; destination
            SET C, J  
            SUB C, 1 ; loop end condition
            ADD J, A
            IFE A, 0
                JMP ROMB699
            STD A, A ; Starting at last character
:ROMB690    STD [J], [I]
            IFU C, J
                JMP ROMB690
:ROMB699    ADD [FRESPC], A ; set pointer to byte after string
            RTS
            
; de-allocate temporary string for immediate use
; [RAM64] should contain a pointer to a string 
;         descriptor, set by STRLIT
; ADDRESS followed by LENGTH
; returns an address in X
;    and a length in A

:FRESTR
:ROMB6A3    ; [VALTYP] should be 0x80
            JSR ROMAD8F  ; check that value is string
:ROMB6A6    SET A, [RAM64]
:ROMB6AA    SET [INDEX], A
            JSR FRETMS   ; Move LASTPT to TEMPPT
            SET Y, [INDEX] ; though it's also in [INDEX]
            SET A, [Y]    ; length?
            SET X, [Y+1]  ; address?
            ; originally loaded XY from 3 bytes
            ; Don't deallocate if...
            IFE Z, 0  ; the original A wasn't LASTPT.
                JMP ROMB6D6
            IFN X, [FREETOP] ; the address isn't top of memory
                JMP ROMB6D6
            ADD [FREETOP], A
            ; XY in original 6502
:ROMB6D6        SET [INDEX], X
:ROMB6DA        RTS

; if A is an entry on the descriptor stack,
; set [TEMPPT] to it and remove it from the stack.
; If A is not found, set Z to 0
:FRETMS
:ROMB6DB    SET Z, 0
            IFN A, [LASTPT]
                RTS
            SET [TEMPPT], A
            SUB A, 2  ; instead of 3
            SET [LASTPT], A
            SET Z, 1
            SET Y, 0
            RTS
:CHRD
:ROMB6EC    JSR ROMB7A1  ; get byte operand
            SET PUSH, X  ; push byte result
            SET A, 1
            JSR ROMB47D   ; create a string 
            SET A, POP
            SET Y, [FACHO]
            SET [Y], A
            SET A, POP
            JMP ROMB4CA ; save descriptor in $61 on stack
:LEFTD
:ROMB700
:RIGHTD
:ROMB72D
:MIDD
:ROMB737
            RTS

:ROMB39E	SET C, 1
			JSR PLOT
:ROMB3A2	SET A, 0
			JMP GIVAYF

; LEN function - valtyp should be String.
:ROMB77C	JSR ROMB782
			JMP ROMB3A2
:ROMB782	JSR ROMB6A3  ; get length in A
			SET [VALTYP], 0 ; returning a number
			SET Y, A     
			RTS

; get an integer that fits into a byte
:GETBYTC
:ROMB79B    JSR CHRGET
:ROMB79E    JSR FRMNUM  ; get formula in FAC
:ROMB7A1    JSR ROMB1B8 ; convert to integer
            SET X, [RAM64]
            JMP CHRGOT

:VAL
:ROMB7AD	JSR ROMB782
			IFE A, 0
				JMP ROMB7B5
			JMP ROMB8F7 ; zero FACEXP and FACSGN
:ROMB7B5	SET X, [RAM7A]
			SET [RAM71], X
			SET A, [INDEX]
			SET [RAM7A], A
			ADD X, A
			; wait, did we just add two pointers?
			; I need to examine what ROMB6A3 returns in [INDEX].
			DAT 0x2000
:ROMB7D7	JSR CHRGOT
			JSR FIN
			SET A, POP
			SET [J], 0
			; move BASIC text cursor to end of string.
:ROMB7E2    SET [RAM7A], [RAM71]
            RTS

; get a POKE address
:ROMB7EB    JSR FRMNUM  ; get an int
            JSR GETADR ; convert to integer
            JSR ROMAEFD ; check for comma
            JMP ROMB79E ; get a byte value

; convert float to integer

:GETADR
:ROMB7F7    IFB [FACSGN], 0x80 ; negative number
            JMP FCERR
        IFG [FACEXP], 0x90 ; > 65535
            JMP FCERR ;illegal quantity
        JSR QINT
        SET [LINNUM], [RAM64]
        RTS



; *** floating point package **

:FADDH
:ROMB849
            SET A, FHALF
            JMP FADD
            
:FSUB
:ROMB850
            JSR CONUPK
:FSUBT
:ROMB853    SET A, [FACSGN]
            XOR A, -1
            SET [FACSGN], A
            XOR A, [ARGSGN]
            ASR A, 15
            SET [ARISGN], A
            SET A, [FACEXP]
            JMP FADDT



:ROMB862    JSR SHIFT_RIGHT
            JMP ROMB8A3

;
;  FLOATING POINT ADDITION.
; should not destroy I, J.
;
:FADD
:ROMB867    JSR CONUPK ; read from pointer in A,
                        ; store to ARG.
:FADDT  ; Add FAC and ARG.  (load FACEXP in A first)
:ROMB86A    ; A = FACEXP
            IFE A, 0  ; 0 + ARG = ARG
                JMP MOVFA ; so return ARG.
            SET [ARGOV], [FACOV]  ;ARGOV?
            SET X, ARGEXP ;  pointer
            SET A, [ARGEXP]    ; A = actual exponent
:ROMB877    SET Y, A
            IFE Y, 0 ; FAC + O = FAC
                RTS  ; so return FAC
:ROMB87B    SUB A, [FACEXP]  ; A = ARGEXP - FACEXP
            IFE A, 0  ; equal exponents
                JMP ROMB8A3
            IFE EX, -1   ; subtraction underflow
                JMP ROMB893
:ROMB881    SET [FACEXP], Y ; Store larger exponent
            SET [FACSGN], [ARGSGN] 
            SET [BITS], 0  ; had to add this for some rsn
            XOR A, 0xFFFF ; 
            ADD A, 1   ; ADC #$00 after a subtract
            SET [ARGOV], 0
            SET X, FACEXP ; a pointer to larger exponent
            JMP ROMB897
            ; enter here when carry clear
:ROMB893    SET [FACOV], 0
:ROMB897    IFU A, -7  ; Big exponent difference 
                JMP ROMB862 
                ;which does this:
                ;JSR ROMB999 ; 
                ;JMP ROMB8A3
            ; I think this is the number of bits
            ; to shift right, in negative 8-bit
            SET Y, A  
            SET A, [FACOV]
:ROMB89E    
            SET C, 0
            SHR [X+1], 1 ; shift mantissa to the right
            ; X-thing is no longer normalized
            JSR ROMB9B0 ; Finish shifting right 
:ROMB8A3    IFC [ARISGN], 0x8000 ; result positive
                JMP NORMAL ; add mantissae and normalize
:FADD4  ; make the result negative if a borrow was done
:ROMB8A7    ; set Y to the other accumulator
            SET Y, FACEXP
            IFN X, ARGEXP
                SET Y, ARGEXP
:ROMB8AF    SET A, [ARGOV]    ; are these two in the right order?
            SUB A, [FACOV]
            SET [FACOV], A
            SET A, [Y+2]
            SBX A, [X+2]
            SET [FACHO+1], A
            SET A, [Y+1]
            SBX A, [X+1]
            SET [FACHO], A
            ; BCS B8D7, then JSR NEGFAC
:ROMB8D2    ;IFN [ARYTAB], [VARTAB]
			;	JMP FACCRASH
			IFE EX, -1 ; one borrow left to do
                JSR NEGFAC
:ROMB8D7    SET Y, 0
:ROMB8D9    SET A, Y
:ROMB8DA    SET C, 0
:ROMB8DB    ; if highest 8 bits of mantissa are
            ; clear, we shift them left here.
            ; probably a better way to do this in 16-bit
            IFB [FACHO], 0xFF00   ; any bits set
                JMP ROMB929  ; skip to single-bit
:ROMB8DF    SHL [FACHO], 8
            SHL [FACHO+1], 8
            BOR [FACHO], EX
            SHL [FACOV], 8
            BOR [FACHO+1], EX
            SET [FACOV], Y
            ADD A, 8
            IFN A, 32  ; we've tried moving 32 bits
                JMP ROMB8DB  ; give up, return 0
:ROMB8F7    SET [FACEXP], 0
            SET [FACSGN], 0
            SET Z, 1
            RTS
:NORMAL ; add fractions then normalize 
; At this point the routine at B999 has
; brought the mantissa in ARGHO to the same
; exponent as FACHO, so we can add them here.
:ROMB8FE
            ADD A, [ARGOV]
            SET [FACOV], A
            ADX [FACHO+1], [ARGHO+1]
            ADX [FACHO], [ARGHO]
            
:ROMB91A    IFE EX, 0
                RTS
            JMP ROMB938 ; Increase exponent to make room
            
; postshift
:ROMB91D    ADD A, 1
            SHL [FACHO], 1
            SHL [FACHO+1], 1
            BOR [FACHO], EX
            SHL [FACOV], 1
            BOR [FACHO+1], EX
:ROMB929    IFC [FACHO], 0x8000
                JMP ROMB91D
:ROMB92B    SUB A, [FACEXP]
            AND A, 0xFF
:ROMB92E    IFE EX, 0 ; no borrow involved
                JMP ROMB8F7 ; zero FACEXP and FACSGN, return
:ROMB930    XOR A, -1
            ADD A, 1
            AND A, 0xFF
:ROMB934    SET [FACEXP], A
:ROMB936    IFC A, 0xFF00 ; this BCC is probably unconditional
                RTS
    ; Add 1 to exponent, and 
    ; shift manitssa to the right by 1.
    ; this leaves the value as a whole unchanged.
    ; carry bit is always set
:ROMB938    ;SET C, EX
            ADD [FACEXP], 1
            IFG [FACEXP], 0xFF
                JMP OVERR
            SHR [FACOV], 1
            SHR [FACHO+1], 1
            BOR [FACOV], EX
            SHR [FACHO], 1
            BOR [FACHO+1], EX
            ;IFN C, 0
                BOR [FACHO], 0x8000
            RTS
            
:NEGFAC ; replace FAC1 with its 2s-complement
:ROMB947    XOR [FACSGN], -1 
:ROMB94D    XOR [FACHO], -1
            XOR [FACHO+1], -1
            XOR [FACOV], 0xFFFF  ; ???
            ADD [FACOV], 0x0001
            ADX [FACHO+1], 0
            ADX [FACHO], 0
            RTS

; increment fraction  only
:ROMB96F    ADD [FACHO+1], 1
            ADX [FACHO], 0
            RTS

:OVERR ; Print overflow error message
:ROMB97E
            ; crash instead for debugging
            ;SET A,0x897E
            ;JMP FACCRASH
            SET X, 0x0F
            JMP ERROR

; I think this routine inserts a byte at the beginning
; of the mantissa, using BITS as a high overflow byte.
:MULSHF 
:ROMB983   SET X, RESHO-1 ; RESHO has no exponent
            ; shift 8 bits from
           ; low $68 -> mantissa -> high $70
:ROMB985    SHR [X+2], 8
            SET [FACOV], EX
            SHR [X+1], 8
            BOR [X+2], EX
            ASR [BITS], 8
            SET Y, [BITS]
            ASR Y, 8 ; Non-descructive shift
            BOR [X+1], EX
:SHIFT_RIGHT          
        ; set X to pointer to FACEXP or ARGEXP before calling here
        ; set A to the actual exponent therein
:ROMB999    ADD A, 8
:ROMB99B    IFB A, 0x80    ; BMI
                JMP ROMB985 ; make 8 more high bits
            IFC A, 0xFF    ; BEQ with low 8 bits
                JMP ROMB985
:ROMB99F    SUB A, 8  ; back to normal
            SET Y, A ; pass exponent to Y
:ROMB9A2    SET A, [FACOV]  ;FAC overflow
            IFC Y, 0x8000 ; SBC #8 resulted in carry set
                JMP ROMB9BA
            ; rotate first byte of mantissa?
            ; here we rotate 16 bits instead of 8
            ; hope that's OK
:ROMB9A6    SHL [X+1], 1
:ROMB9AA    BOR [X+1], EX
            SET C, EX
            ; ROR [X+1] -> [X+2] -> A
:ROMB9AC    SHR [X+1], 1
            BOR [X+1], C
            SET C, EX  
:ROMB9AE    SHR [X+1], 1
            BOR [X+1], C 
            ; might jump here if X+1 is already shifted
:ROMB9B0    SET C, EX
            SHR [X+2], 1
            
:ROMB9B0A   BOR [X+2], C
:ROMB9B6    SET C, EX
            SHR A, 1
            BOR A, C
            
:ROMB9B7    ADD Y, 1    ; add one to exponent diff
            IFB Y, 0x00FF  ; low bits not equal 0
                JMP ROMB9A6  ; do magic bits again
:ROMB9BA    SET C, 0
            SET EX, 0
            RTS  ; A contains 0x00 through 0xFF00
                    ; as fetched from FACOV?

                    
; FP constant ONE
; default STEP for FOR statement
:FONE
:ROMB9BC  DAT 0x81, 0, 0

; FP constants for LOG
:LOGCN2
:ROMB9C1 DAT 0x03   ; degree 4
:ROMB9C2  DAT 0x7F,0x5E56,0xCB79
:ROMB9C7  DAT 0x80,0x139B,0x0B64
:ROMB9CC  DAT 0x80,0x7638,0x9316
:ROMB9D1  DAT 0x82,0x38AA,0x3B20

:ROMB9D6  DAT 0x80,0x3504,0xF334   ; 0,5 * SQR(2)
:ROMB9DB  DAT 0x81,0x3504,0xF334   ; SQR(2)
:ROMB9E0  DAT 0x80,0x8000,0x0000   ; -1/2
:ROMB9E5  DAT 0x80,0x3172,0x17F8   ; LOG(2)



; FAC1 <- ln FAC1
:LOG
:ROMB9EA    DAT 0x4100

; FAC1 <- FAC1 * FAC2
:FMULT
:ROMBA28    JSR CONUPK
; times operator
:FMULTT
:ROMBA2B    IFE A, 0  
                RTS ; anything times 0 = 0
            JSR MULDIV ; add exponents
            SET [RESHO], 0
            SET [RESHO+1], 0
:ROMBA3D    SET A, [FACOV]
            JSR ROMBA59  ; multiply A and add to RESHO
            SET A, [FACHO+1]
            JSR ROMBA59  
            SET A, [FACHO]
            JSR ROMBA59
            JMP ROMBB8F  ; ???

            ; BYTE-SHIFT ADDER
:ROMBA59    SET [FACOV], [RESHO+1]
			SET [RESHO+1], [RESHO]
			SET [RESHO], 0
			SET Y, A
			MUL Y, [ARGHO]
			SET X, EX
			ADD [RESHO+1], Y
			ADX [RESHO], X
			SET Y, A
			MUL Y, [ARGHO+1]
			SET X, EX
			ADD [FACOV], Y
			ADX [RESHO+1], X
			ADX [RESHO], 0
			IFN EX, 0 ; should be impossible
				JMP FACCRASH ;unless i'm very wrong
			RTS

; move float indexed by AY into second float accu
; return FAC1's exponent in A to enable special
; zero-handling and a few shortcuts.
:CONUPK
:ROMBA8C    SET [INDEX], A
:ROMBA8CI   SET [ARGEXP], [A]
            SET B, [A+1]
            SET [ARGSGN], B
            ASR [ARGSGN], 15  ; pure 0 or -1
            SET [ARGHO], B
            BOR [ARGHO], 0x8000 ; high bit is always 1
            XOR B, [FACSGN]
            ASR B, 15   ; pure 0 or -1
            SET [ARISGN], B
            SET [ARGHO+1], [A+2]
            SET A, [FACEXP]
            RTS
; Add exponents of ARG and FAC
; (called by FMULT and FDIV)
; also check for overflow and set result sign
:MULDIV
:ROMBAB7    SET A, [ARGEXP]
            IFE A, 0
                JMP ROMBADA ; just copy I guess
            ADD A, [FACEXP]
            IFC A, 0x100 ; BCC
                JMP ROMBAC4
            IFB A, 0x80  ; BMI
                JMP OVERR  ; originally BADF
:ROMBAC2    AND A, 0xFF ; CLC
            JMP ROMBAC6  ; .BY $2C to jump next BPL 
:ROMBAC4    IFC A, 0x80 ; BPL
                JMP ROMBADA
:ROMBAC6    ADD A, 0x80
            AND A, 0xFF
            SET [FACEXP], A
            IFN A, 0
                JMP ROMB8FB ; set FACSGN too and RTS.
            ; put comparison result into ARISGN
:ROMBACF    SET [FACSGN], [ARISGN]
:ROMBAD3    RTS
:ROMB8FB	SET [FACSGN], A
			RTS
; if FAC is positive, give OVERR
; if FAC is negative, set FAC=0, pop one return,
; and RTS.  called from EXP function
:MLDVEX
:ROMBAD4    SET A, [FACSGN]
            XOR A, -1
            IFB A, 0x8000
                JMP OVERR
; pop return address and set FAC=0
:ROMBADA    SET A, POP
            ; popped values will be discarded
            JMP ROMB8F7 ; zero FACEXP and FACSGN

; This quick-multiplies FAC by 10 through bit shifting
; and addition.
:MUL10
:ROMBAE2    JSR MOVAF ; ARG = FAC
:ROMBAE5    IFE A, 0   ; (A is [FACEXP] now) 
                RTS ; 0 * 10 = 0
:ROMBAE9    ADD A, 2  ; ARG *= 4 by increasing exponent
            IFB A, 0x100
                JMP OVERR
:ROMBAED    SET [ARISGN], 0
            JSR ROMB877  ; FAC += ARG
            ADD [FACEXP], 1  ; FAC *= 2
            IFB [FACEXP], 0x100
                JMP OVERR
            RTS

; division doesn't work yet, so I'm going to
; multiply by 0.1 instead
:DIV10
    JSR MOVAF  ; ARG = FAC
	SET [FACHO], 0xCCCC
	SET [FACHO+1], 0xCCCC
	SET [FACOV], 0xCCCD
	SET A, 0x7D
	SET [FACEXP], A
	SET [FACSGN], 0
	SET [ARISGN], 0
	JMP FMULTT
	;JMP FACCRASH
	

; FP constant TEN for division
; (there's no shortcut trick like in multiplying)
:TENC
:ROMBAF9
        DAT 0x84, 0x2000, 0x0000

:REALDIV10
:ROMBAFE
        JSR MOVAF  ; ARG = FAC
        SET A, TENC
        SET X, 0
        SET [ARISGN], X
        JSR MOVFM  ; FAC1 = 10
        JMP FDIVT ; return FAC/10

; FAC <- ARG / FAC
:FDIV
:ROMBB0F    JSR CONUPK ; copy to ARG; should return exp in A
:FDIVT
:ROMBB12    IFE A, 0  ; dividing by 0?
                JMP ROMBB8A ; oh shi--
            JSR ROUND
            SET A, 0
			SUB A, [FACEXP]
            AND A, 0xFF
            SET [FACEXP], A
            JSR MULDIV ; add exponents
            ; works fine up to here
:ROMBB21    ADD [FACEXP], 1
            IFB [FACEXP], 0x100
                JMP OVERR
:ROMBB25    SET X, RESHO-1
            SET A, 1 ; "stop" bit -- when this 1 goes off the
                     ; left side of A, we store the byte to [X+1].
:ROMBB29    SET Y, [ARGHO]
			SUB Y, [FACHO]
			IFN Y, 0
			    JMP ROMBB3F
			SET Y, [ARGHO+1]
			SUB Y, [FACHO+1]
            ;6502: Carry bit is set if ARGHO >= FACHO
            ; or if the shift-left at ROMBB4F
            ; resulted in an overflow
            ;DCPU: EX = -1 represents carry clear case
            ;      EX = 0 represents carry set case
:ROMBB3F    SET PUSH, EX ; simulate PHP
            SHL A, 1  ; shifting part of ROL
            SET C, EX ; store carry bit off left side of A
            IFE PEEK, 0
                BOR A, 1 ; carry-add part of ROL
            IFE C, 0 ; no bit fell off off left side
                JMP ROMBB4C
            ; the 1 that is in C is the guard bit we initially
            ; set in A. this means we have enoiugh bits in A
            ; to store a byte into RESHO now.
            ADD X, 1  
            SET [X], A
            IFE X, RESHO+1
                JMP ROMBB7A
            IFG X, RESHO+1
                JMP ROMBB7E  ; Store to [FACOV]
            SET A, 1 ; "stop" bit of next byte
:ROMBB4C    SET EX, POP
:ROMBB4D    IFE EX, 0
                JMP ROMBB5D
            ; subtract 1 at left of ARGHO and re-normalize.
:ROMBB4F    SHL [ARGHO], 1
            SET C, EX
            SHL [ARGHO+1], 1
            BOR [ARGHO], EX
            IFN C, 0 ; bit fell off left side of mantissa
                JMP ROMBB3F ; rotate A left too.
            IFB [ARGHO], 0x8000  ; ARG is normalized
                JMP ROMBB29 ; subtract again
            JMP ROMBB3F
            ; originally BB5D preserved  A. 
:ROMBB5D    SUB [ARGHO+1], [FACHO+1]
            SBX [ARGHO], [FACHO]
            JMP ROMBB4F
:ROMBB7A    SET A, 0x4000 
			JMP ROMBB4C
:ROMBB7E    SHL A, 14 ; originally 6
            SET [FACOV], A
            SET EX, POP  ; PLP?
            JMP ROMBB8F
:ROMBB8A    SET X, 0x14  ; OH SHI--
            JMP ERROR
:ROMBB8F    SET [FACHO], [RESHO]
            SET [FACHO+1], [RESHO+1]
            JMP ROMB8D7 ; normalize before returning
            
	

; Move a FP number from memory pointer in A to FAC1
:MOVFM
:ROMBBA2    SET [FACEXP], [A]
            SET Y, [A+1]
            SET [FACHO], Y
            SET [FACHO+1], [A+2]
            ASR Y, 15
            SET [FACSGN], Y
            BOR [FACHO], 0x8000
            SET [FACOV], 0
            RTS


; Move a FP number from FAC1 to various points in memory
:MOV2F
:ROMBBC7
            SET X, RAM5C ; arithmetic register #4
            IFE X, 0 ; skip next
:ROMBBCA        SET X, RAM57 ; arithmetic register #3
            IFE X, 0 ; skip next
:ROMBBD0    SET X, [FORPNT]
:ROMBBD4    JSR ROUND
            ; using X instead of $22
            SET [X+2], [FACHO+1] ; low mantissa
            SET A, [FACSGN]
            BOR A, 0x7FFF 
            AND A, [FACHO] ; high mantissa combined with sign bit
            SET [X+1], A
            SET [X], [FACEXP]
            SET [FACOV], 0 
            ; uncomment if something relies on INDEX
            SET [INDEX], X
            RTS
            
; Move from FAC2 to FAC1
:MOVFA
:ROMBBFC    SET [FACSGN], [ARGSGN]
            SET [FACHO+1], [ARGHO+1]
            SET [FACHO], [ARGHO]
            SET [FACEXP], [ARGEXP]
            SET [FACOV], 0
            RTS
; MOVE rounded FAC into ARG
:MOVAF 
:ROMBC0C    JSR ROUND
:MOVEF
:ROMBC0F    SET [ARGSGN], [FACSGN]
            ASR [ARGSGN], 15 ; Attempt
            SET [ARGHO+1], [FACHO+1]
            SET [ARGHO], [FACHO]
            SET [ARGEXP], [FACEXP]
            SET [FACOV], 0
            ; Preserve side effect in 6502 version
            SET A, [FACEXP]
            RTS

; Round Accumulator #1 by Adjusting the Rounding Byte
:ROUND
:ROMBC1B    IFE [FACEXP], 0
                RTS
            SHL [FACOV], 1
            IFE EX, 0
                RTS
            ; increment mantissa
            ADD [FACHO+1], 1
            ADX [FACHO], 0  
            IFE EX, 0
                RTS
            ; mantissa overflowed;
            ; shift it to the right
            JMP ROMB938
            
; get sign of float accu in A
:SIGN
:ROMBC2B    SET A, [FACEXP]
            IFE A, 0
                RTS
:ROMBC2F    SET A, [FACSGN]
; Return pure +1 or -1.
:ROMBC31    ASR A, 15
            BOR A, 1
            RTS

; SGN function
:ROMBC39
        JSR SIGN

; Move signed 8-bit number from A into float

:ROMBC3C
        SHL A, 8
        SET [FACHO], A ; Mantissa
        SET [FACHO+1], 0
        SET X, 0x88
        SET [FACEXP], X
:ROMBC44
        SET A, [FACHO]
        ; 6502 version set carry bit to opposite 
        ; of high bit of FACHO.
        ; used at BD02 to determine whether
        ; to call NEGFAC.
        SET EX, 0
        IFB A, 0x8000
            SET EX, -1
; Zero out rest of FACHO
:ROMBC49
        SET A, 0
        SET [FACEXP], X
        SET [FACHO+1], A
        SET [FACOV], A
        SET [FACSGN], A
        JMP ROMB8D2
            ;... does a NEGFAC if EX = -1,
            ; then normalizes the thing

; ABS FUNCTION
:ROMBC58
        SET [FACSGN], 0
        RTS
            

;Compare FAC1 to Memory
; returns: A = -1 if FAC1 is lower
;              +1 if FAC1 is higher
:FCOMP
:ROMBC5B    SET I, A    ; I points to exponent
:FCOMPI
:ROMBC5D    SET X, [I]  ; X contains exponent
:ROMBC63    ADD I, 1    ; I points to mantissa
            IFE X, 0
                JMP SIGN ; return sign of FAC1?
:ROMBC67    SET A, [I]  ; A contains mantissa 
            XOR A, [FACSGN]
            IFB A, 0x8000  ; Comparing different signs
                JMP ROMBC2F
            ; Compare exponent, then mantissa
            ; First byte that's different,
            ; return comparison of that byte.
:ROMBC6D    SUB X, [FACEXP]
            IFN X, 0  ; different exponents
                JMP ROMBC92
            SET X, [I]
            BOR X, 0x8000
            SUB X, [FACHO]
            IFN X, 0
                JMP ROMBC92
            SET X, [I+1]
            SUB X, [FACHO+1]
            IFN X, 0
                JMP ROMBC92
            ; try subtraction again,
            ; this time with the rounding bit
:ROMBC88    SET EX, -1
            IFB [FACOV], 0x8000
                SET EX, 0
:ROMBC8C    SET X, [I+1]

            SBX X, [FACHO+1]
            SET A, 0
:ROMBC90    IFE X, 0
                RTS ; give up on comparison?
; in 6502, C=1 meant memory was higher..
; in DCPU-16, EX=0 meant memory was higher.
:ROMBC92    SET A, [FACSGN]
            IFE EX, 0 ; no underflow in the subtract
                XOR A, -1
            JMP ROMBC31 ; return pure 0 or 1

; ----------------------------------------------------------------------------
; QUICK INTEGER FUNCTION
;
; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
;
; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
; ----------------------------------------------------------------------------

:QINT
:ROMBC9B    SET A, [FACEXP]
            IFE A, 0
                JMP ROMBCE9 ; clear mantissa and return
:ROMBC9F    SUB A, 0xA0
            AND A, 0xFF
            IFC [FACSGN], 0x8000
                JMP ROMBCAF ; skip two lines if positive
            SET [BITS], -1  ; shift 1s from the left instead of 0s
            JSR ROMB94D  ; multiply mantissa by -1
:ROMBCAF    SET X, FACEXP ; pointer to MULSHF operand
            IFG A, 0xF8   ; CMP 0xF9
                JMP ROMBCBB
            JSR SHIFT_RIGHT  ; MULSHF offset
            SET [BITS], Y
:ROMBCBA    RTS
            
:ROMBCBB    SET Y, A
            SET A, [FACSGN]
            AND A, 0x8000
            SHR [FACHO], 1
            BOR [FACHO], A
            JSR ROMB9B0 ; shift rest of FACHO to the right
            SET [BITS], Y
            ; investigate loss of precision:
            ; 
:ROMBCCB    RTS

:INT
:ROMBCCC    IFG [FACEXP], 0xA0  ; too big to have decimal places
                RTS
            JSR QINT
            SET [FACOV], Y
            SET A, [FACSGN]
            SET [FACSGN], Y
            ;EOR #$80
            ;ROL
            
                
:ROMBCE9    SET [FACHO], 0
            SET [FACHO+1], 0
            RTS

:DECFLG	DAT 0
:FIN ; convert ascii string to a float in FAC1
:ROMBCF3    SET Y, 0
            SET X, 0
            SET [DECEXP], 0
            SET [RAM5E], 0
            SET [DECFLG], 0
            SET [RAM60], 0
            SET [FACEXP], 0
            SET [FACHO], 0
            SET [FACHO+1], 0
            SET [FACSGN], 0
            ; parse result from last CHRGET
            IFE C, 0
                JMP ROMBD6A ; is a digit
            IFN A, 0x2D ; minus
                JMP ROMBD06
            SET X, -1
:ROMBD02    SET [SGNFLG], X  ; is a positive number
:ROMBD06    IFN A, 0x2B ; plus sign
                JMP ROMBD0F 
            ; get digit after +/-
:ROMBD0A    JSR CHRGET
            ; parse a digit
:ROMBD0D    IFE C, 0    ; is a digit
                JMP ROMBD6A
:ROMBD0F    IFE A, 0x2E ; decimal point
                JMP ROMBD41
            IFN A, 0x45 ; E
                JMP ROMBD47
            ; handle exponent notation
            JSR CHRGET
            IFE C, 0  ; is a digit
                JMP ROMBD91
            IFE A, BASIC_MINUS_TOKEN
                JMP ROMBD2E
            IFE A, 0x2D  ; minus
                JMP ROMBD2E
            IFE A, BASIC_PLUS_TOKEN
                JMP ROMBD30
            IFE A, 0x2B  ; plus
                JMP ROMBD30
            JMP ROMBD35
            ; handle negative exponent
:ROMBD2E    SET [RAM60], -1
:ROMBD30    JSR CHRGET
            IFE C, 0 ; is a digit?
                JMP ROMBD91
:ROMBD35    IFN [RAM60], -1 ; bpl
                JMP ROMBD47
            SET A, 0
            SUB A, [RAM5E]
            JMP ROMBD49 ; subtract DECEXP and use.
            ; handle decimal point
:ROMBD41    SHR [DECFLG], 1       ; move existing decimal point flag
            BOR [DECFLG], 0x8000  ; set decimal point flag
            IFC [DECFLG], 0x4000 ; if decimal point flag already set
                JMP ROMBD0A ; ignore second decimal
            ; Normalize number with E+xx/E-xx notation.
:ROMBD47    SET A, [RAM5E]   
:ROMBD49    SUB A, [DECEXP]
            SET [RAM5E], A
            IFE A, 0
                JMP ROMBD62 ; no decimal point
            IFA A, -1 ; BPL
                JMP ROMBD5B
            ; Decimally denormalize number.
            ; RAM5E is the decimal exponent
            ; DECEXP is the number of digits to the right 
:ROMBD52    JSR DIV10
            ADD [RAM5E], 1
            IFN [RAM5E], 0
                JMP ROMBD52
            JMP ROMBD62
:ROMBD5B    JSR MUL10
            SUB [RAM5E], 1
            IFN [RAM5E], 0
                JMP ROMBD5B
:ROMBD62    SET A, [SGNFLG]
            IFB A, 0x8000  ; BMI
                JMP NEGOP ; originally via BD67
            RTS
; handle a digit
:ROMBD6A    IFE A, 0x2E    ; decimal point, should not be here.
				JMP CRASH
			SET PUSH, A
            IFB [DECFLG], 0x8000 ; after a decimal point
                ADD [DECEXP], 1 ; increase decimal exponent
            JSR MUL10  ; multiply decimal mantissa regardless
            SET A, POP
            SUB A, 0x30 ; zero
            JSR FINLOG  ; add contents of digit
            JMP ROMBD0A ; go to next character

:DERP DAT 0

            
; Add signed integer from A to float accu
:FINLOG
:ROMBD7E    SET PUSH, A
            JSR MOVAF ; ARG = FAC
            SET A, POP
            JSR ROMBC3C  ; move A into FAC
			
            SET A, [ARGSGN]
            XOR A, [FACSGN]
            ASR A, 15
            SET [ARISGN], A
            SET A, [FACEXP]
            JMP FADDT

; get E+xx/E-xx exponent from string
:ROMBD91    SET A, [RAM5E] ; number of received digits
            IFL A, 10
                JMP ROMBDA0
            SET A, 100
            IFB [RAM60], 0x8000 ; BMI
                JMP ROMBDAE
            JMP OVERR ; ?OVERFLOW ERROR
            ; i think this handles E+XX
:ROMBDA0    MUL A, 10
            AND A, 0xFF ; simulate some 8-bit quirk
            SET Y, [RAM7A]
            ADD A, [Y]
            SUB A, 0x30 ; un-digit
:ROMBDAE    SHL A, 8 ; 8-bit quirk simulation
			ASR A, 8 ; continues
			SET [RAM5E], A
            JMP ROMBD30 ; get next expodigit
            
:NO999
; constants for float to string conversion
:ROMBDB3   DAT 0x9B, 0x3EBC, 0x1FFD
:ROMBDB8   DAT 0x9E, 0x6E6B, 0x27FD
:ROMBDBD   DAT 0x9E, 0x6E6B, 0x2800


; print "IN <line>"
:INPRT
:ROMBDC2    SET A, ROMA371
            JSR STROUT ;originally ROMBDDA
            SET A, [CURLIN]

; print number from A (AX in original)

:LINPRT
:ROMBDCD    SET [FACHO], A
            SET X, 0x90 ;  exponent = 2^16
            SET EX, 0 ; don't run NEGFAC from B8D2
            JSR ROMBC49  ; normalize this
            JSR FOUT     ; convert float to string
            JMP STROUT   ; print
   
:FLOATSTR   
            DAT 0x0
            .FILL 32 0x0
; output floating point number in FAC1
:FOUT
:ROMBDDD    SET Y, FLOATSTR
:ROMBDDF    ;SET [FACOV], 0 ; TODO: cleanup
            SET A, 0x20    ; SPACE
            IFB [FACSGN], 0x8000
                SET A, 0x2D ; MINUS
            SET [Y], A
            SET [FACSGN], A
            SET [RAM71], Y
            ADD Y, 1
            SET A, 0x30 ; zero
            SET X, [FACEXP]
            IFE X, 0
                JMP ROMBF04  ; write zero and exit
:ROMBDF8    SET A, 0
            IFE X, 0x80 ; exponent is a 1
                JMP ROMBE00
            IFG X, 0x80 ; number > 1
                JMP ROMBE09
; For numbers between 0 and 1, we skip 9 digits
:ROMBE00    SET A, ROMBDBD  ;  1,000,000,000
            JSR FMULT 
            SET A, -9 ; signify we've moved the decimal point
:ROMBE09    SET [DECEXP], A
:ROMBE0B    SET A, ROMBDB8
            JSR FCOMP 
:ROMBE12    IFE A, 0  ; FAC1 = 999,999,999.5
                JMP ROMBE32
            IFC A, 0x8000 ; FAC1 > 999,999,999.5
                JMP ROMBE28 
:ROMBE16    SET A, ROMBDB3
            JSR FCOMP
:ROMBE1D    IFE A, 0 ; fac1 = 99,999,999.5
                JMP ROMBE21 ; squeeze one more out
            IFC A, 0x8000 ; FAC1 > 99,999,999.5
                JMP ROMBE2F ; hundred millions digit done
:ROMBE21    ; Keep multiplying by 10 until
            ; the number is as big as we can print.
            JSR MUL10
            SUB [DECEXP], 1
            IFN [DECEXP], 0
                JMP ROMBE16
:ROMBE28    JSR DIV10
:ROMBE2A    ADD [DECEXP], 1
            IFN [DECEXP], 1
                JMP ROMBE0B
            ; We've inflated our number, and the
            ; decimal exponent is in DECEXP.
:ROMBE2F    JSR FADDH ; add 0.5 to round the last visible digit
:ROMBE32    JSR QINT
:ROMBE35    SET X, 1
            SET A, [DECEXP]
            ADD A, 10
            IFB A, 0x8000 
                JMP ROMBE47
            IFG A, 10  ; More than 10 digits?
                JMP ROMBE48
:ROMBE42    ADD A, -1   
            SET X, A
            SET A, 2
:ROMBE47    ADD A, 1   ; simulate SEC
:ROMBE48    SUB A, 3   ; simulate SBC with possible CLC
            SET [RAM5E], A
            ;Store the positive number of digits
            ; to the left of the decimal point.
            SET [DECEXP], X 
            SET A, X
            IFE A, 0
                JMP ROMBE53
            IFC A, 0x8000
                JMP ROMBE66
:ROMBE53    SET Y, [RAM71]   ; cached FLOATSTR index
            ADD Y, 1
            SET [Y], 0x2E ; decimal point
            SET A, X
            JMP ROMBE64
:ROMBE5E    ADD Y, 1
            SET [Y], 0x30
:ROMBE64    SET [RAM71], Y
:ROMBE66    SET B, FOUTBL
:ROMBE68    SET X, 0x80
:ROMBE6A    ADD [FACHO+1], [B+1]
:ROMBE6G    ADX [FACHO], [B]
            SET C, EX
            ADD X, 1  ; 6502: affects N, not C
            IFN C, 0
                JMP ROMBE8E
:ROMBE8A    IFC X, 0x80 ;BPL
                JMP ROMBE6A
            JMP ROMBE90 ;BMI
:ROMBE8E    IFB X, 0x80 ;BMI after BCD
                JMP ROMBE6A
:ROMBE90    SET A, X
            IFE C, 0
                JMP ROMBE97
:ROMBE93    XOR A, 0xFF
            ADD A, 12 ; ADC #10 when carry must bet set
:ROMBE97    ADD A, 0x2F ; ??
:ROMBE99    ADD B, 2 ; Try next divisor
            ;SET [VARPNT],B  ; Starting divisor cache
            SET Y, [RAM71] ; get cached string index
            ADD Y, 1
            SET X, A
:ROMBEA3    AND A, 0x7F
            SET [Y], A     ;Store a digit!
            SUB [DECEXP], 1
            IFN [DECEXP], 0 
                JMP ROMBEB2
            ADD Y, 1
            SET [Y], 0x2E ; Add decimal point
:ROMBEB2    SET [RAM71], Y ; Store string index
            ;SET B, [VARPNT]  ; Cached divisor value
            SET A, X
            XOR A, 0xFF
            AND A, 0x80  ; not sure the bittitude
            SET X, A
            IFE B, FOUTBLEND ; end of base 10 factors
                JMP ROMBEC4
            IFN B, FDCEND  ; end of TI$ factors
                JMP ROMBE6A  ; beginning of loop
:ROMBEC4    SET Y, [RAM71]
    ; shave off surplus decimal places
:ROMBEC6    SET A, [Y]
            SUB Y, 1
            IFE A, 0x30 ; zero
                JMP ROMBEC6
            IFE A, 0x2E ; decimal point
                JMP ROMBED3
            ADD Y, 1
:ROMBED3    SET A, 0x2B ; plus
            SET X, [RAM5E]
            IFE X, 0   ; Nothing more to print
                JMP ROMBF07
            ; What's in RAM5E anyway?
:ROMBED9    IFC X, 0x80 
                JMP ROMBEE3
:ROMBEDB    SET X, [RAM5E]
            MUL X, -1
            SET A, 0x2D ; minus
:ROMBEE3    SET [Y+2], A
            SET [Y+1], 0x45 ; E
            SET A, X
            SET X, 0x2F 
:ROMBEEE    ; SEC
:ROMBEEF    SET A, X
            DIV A, 10
            MOD X, 10
            SET [Y+4], X
            SET [Y+3], A
            SET [Y+5], 0
            JMP ROMBF0C
:ROMBF04    SET [Y], A
:ROMBF07    SET [Y+1], 0
:ROMBF0C    SET A, FLOATSTR
            SET Z, 0
            RTS
            
; constant: 1/2 in floating point format
; for various rounding purposes.
:FHALF
:ROMBF11   DAT 0x80, 0x0000, 0x0000 

; the NOTFNS routine points here when there's an array,
; but there's nothing special there
;  $00,$00,$00,$FA,$0A,$1F,$00
; i'll put some random approximation of what's there there
; and hope it pays off.
:ROMBF13    DAT 0,0,0xFA0A,0x1F00

; divisors for decimal conversion
:FOUTBL
:ROMBF16   DAT 0xFA0A,0x1F00    ;leftmost digit
:ROMBF1A   DAT 0x0098,0x9680    ;
:ROMBF1E   DAT 0xFFF0,0xBDC0    ;
:ROMBF22   DAT 0x0001,0x86A0    ;
:ROMBF26   DAT 0xFFFF,0xD8F0    ;
:ROMBF2A   DAT 0x0000,0x03E8    ;
:ROMBF2E   DAT 0xFFFF,0xFF9C    ;
:ROMBF32   DAT 0x0000,0x000A    ;
:ROMBF36   DAT 0xFFFF,0xFFFF    ;rightmost digit
:FOUTBLEND

; divisors for clock conversion (TI$)
:FDCEND
    DAT 0xFFDF,0x0A80
    DAT 0x0003,0x4BC0
    DAT 0xFFFF,0x7360
    DAT 0x0000,0x0E10
    DAT 0xFFFF,0xFDA8
    DAT 0x0000,0x003C
:FDCENDEND

; MINUS operator
; Perform NOT and >
:NEGOP
:ROMBFB4    IFE [FACEXP], 0
                RTS
            XOR [FACSGN], -1
            RTS

; EXP command
:ROMBFED    SET EX, 0xBFED
            SET C, PC
            JMP CRASH

; Error handler for IO calls
:ROME0F9    IFN A, 0xF0
                JMP ROME104
            ; 0xF0 is a special error?
            SET [MEMSIZ], X
            JMP ROMA663
:ROME104    IFE X, 0
                SET X, 0x1E   ; BREAK
            JMP ERROR

; CHROUT plus error checking for BASIC
; (treats EX as error flag, X as error number)
:ROME10C    JSR CHROUT
            IFN EX, 0 ; carry bit set
                JMP ROME0F9
            RTS
:ROME112    JSR CHRIN
            IFG EX, 0
                JMP ROME0F9
            RTS
:ROME118    JSR ROME4AD
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME11E    JSR CHKIN
            IFG C, 0
                JMP ROME0F9
            RTS
:ROME124    JSR GETIN
            IFG C, 0
                JMP ROME0F9
            RTS
            
:ROME4AD
            SET PUSH, A
            JSR ROMFFC9
            SET  X, A
            SET A, POP
            IFE C, 0
                RTS
            SET A, X
            RTS

:XFACCRASH  SET I, [X+1]
            SET J, [X+2]
            SET EX, [X]
            SET Z, [X+3]
            JMP CRASH
:FACCRASH   SET B, [ARGHO]
			SET C, [ARGHO+1]
			SET X, [ARGEXP]
			SET A, [ARGSGN]
			SET Y, [ARISGN]
			SET I, [FACHO]
            SET J, [FACHO+1]
            SET EX, [FACEXP]
            SET Z, [FACSGN]
            BOR 0xBCBC, 0xBCBC
            JMP CRASH
